    // ... (Supabase init और saveTestAttemptToSupabase फंक्शन unit1 की तरह ही) ...

    function submitQuiz() {
      // ... (स्कोर गणना पहले की तरह) ...
      const percentage = ((score / questions.length) * 100).toFixed(2);
      document.getElementById("result").innerHTML = `आपका स्कोर: ${score}/${questions.length} (${percentage}%)`;
      // ... (completionMessageElement लॉजिक पहले की तरह) ...

      // Save attempt to Supabase
      const unitId = "unit4"; // <<<--- यहाँ unitId बदला गया है
      const totalAttemptedQuestions = questions.length;
      const incorrectAnswers = totalAttemptedQuestions - score;
      
      saveTestAttemptToSupabase(unitId, score, incorrectAnswers, totalAttemptedQuestions)
        .then(saved => {
            if (saved) alert("आपका परीक्षा परिणाम सफलतापूर्वक सहेज लिया गया है!");
        });
    }
    // ... (बाकी JavaScript कोड पहले की तरह) ...
<!DOCTYPE html>
<html lang="hi">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Unit-4</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <style>
    body {
      font-family: 'Poppins', sans-serif;
      background: linear-gradient(135deg, #fdfbfb 0%, #ebedee 100%);
      margin: 0;
      padding-left: 240px;
      color: #333;
      transition: padding-left 0.3s ease;
    }
    .sidebar {
      position: fixed;
      top: 0;
      left: 0;
      width: 240px;
      height: 100%;
      background: linear-gradient(to bottom, #667eea, #764ba2);
      padding: 20px 10px;
      box-shadow: 2px 0 10px rgba(0,0,0,0.1);
      overflow-y: auto;
      transition: transform 0.3s ease;
      display: flex;
      flex-direction: column;
      z-index: 1000;
    }
    .sidebar.hidden {
      transform: translateX(-260px);
    }
    .sidebar:not(.hidden) {
      transform: translateX(0);
    }
    .toggle-btn {
      position: fixed;
      top: 15px;
      left: 15px;
      width: 30px;
      height: 30px;
      cursor: pointer;
      z-index: 1002;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
    }
    .toggle-btn span {
      display: block;
      height: 4px;
      background: #333;
      border-radius: 2px;
    }
    body.sidebar-visible {
      padding-left: 240px;
    }
    .sidebar h2 {
      color: #fff;
      font-size: 20px;
      margin-bottom: 15px;
      text-align: center;
    }
    .sidebar table {
      width: 100%;
      border-spacing: 5px;
      margin-bottom: 20px;
    }
    .sidebar td {
      text-align: center;
    }
    .sidebar td a {
      display: block;
      background: #ccc;
      color: #333;
      font-weight: bold;
      text-decoration: none;
      padding: 6px;
      border-radius: 6px;
      transition: all 0.3s;
      position: relative;
    }
    .sidebar td a:hover {
      background: #ffd166;
      color: #000;
    }
    .sidebar td a.correct {
      background: #a5d6a7 !important;
      color: #1b5e20 !important;
    }
    .sidebar td a.incorrect {
      background: #ef9a9a !important;
      color: #b71c1c !important;
    }
    .sidebar td a.active {
      background: #ffd166 !important;
      color: #000 !important;
    }
    .sidebar td a.unanswered::after {
      content: "?";
      position: absolute;
      top: -6px;
      right: -6px;
      background: #bbb;
      color: white;
      font-size: 10px;
      width: 16px;
      height: 16px;
      line-height: 16px;
      border-radius: 50%;
    }
    .quiz-container {
      max-width: 800px;
      margin: 30px auto;
      background: #fff;
      border-radius: 12px;
      padding: 30px;
      box-shadow: 0 15px 40px rgba(0,0,0,0.1);
    }
    .question {
      font-size: 20px;
      font-weight: 600;
      margin-bottom: 20px;
    }
    label {
      display: block;
      background: #f1f1f1;
      padding: 12px 18px;
      margin: 10px 0;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    label:hover {
      background: #dceefb;
    }
    label.correct {
      background: #a5d6a7;
      border-left: 6px solid #1b5e20;
    }
    label.incorrect {
      background: #ef9a9a;
      border-left: 6px solid #b71c1c;
    }
    label.locked {
      pointer-events: none;
      opacity: 0.6;
    }
    .navigation {
      display: flex;
      justify-content: space-between;
      margin-top: 20px;
    }
    button {
      padding: 10px 18px;
      border: none;
      background: linear-gradient(to right, #43cea2, #185a9d);
      color: #fff;
      font-weight: bold;
      border-radius: 6px;
      cursor: pointer;
      transition: background 0.3s ease;
    }
    button:hover {
      background: linear-gradient(to right, #185a9d, #43cea2);
    }
    #result {
      margin-top: 20px;
      font-size: 18px;
      text-align: center;
      font-weight: bold;
      color: #185a9d;
    }
    .correct-answer {
      margin-top: 15px;
      font-weight: 600;
      color: #2e7d32;
    }
    .explanation {
      margin-top: 15px;
      padding: 10px;
      background-color: #f9f9f9;
      border-left: 4px solid #764ba2;
      font-size: 16px;
      color: #333;
    }
    body.dark {
      background: #121212;
      color: #e0e0e0;
    }
    body.dark .quiz-container {
      background: #1e1e1e;
    }
    body.dark label {
      background: #333;
    }
    body.dark .sidebar {
      background: #2c3e50;
    }
    body.dark .explanation {
        background-color: #2a2a2a;
        border-left-color: #9b70e0;
        color: #e0e0e0;
    }
    .tools-section {
      margin-bottom: 20px;
      padding-bottom: 15px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.3);
      text-align: center;
    }
    .tools-section h2 {
      margin-bottom: 15px;
      color: #fff;
      font-size: 20px;
      text-align: center;
    }
    .tools-section .button {
      display: block;
      width: 90%;
      margin: 10px auto;
      padding: 10px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-weight: bold;
      text-align: center;
      transition: background 0.3s ease;
      color: white;
    }
    .tools-section .theme-btn {
      background: linear-gradient(to right, #43cea2, #185a9d);
    }
    .tools-section .theme-btn:hover {
      background: linear-gradient(to right, #185a9d, #43cea2);
    }
    .tools-section .fullscreen-btn {
      background: linear-gradient(to right, #f39c12, #e67e22);
    }
    .tools-section .fullscreen-btn:hover {
      background: linear-gradient(to right, #e67e22, #f39c12);
    }
    .tools-section .clear-data-btn {
      background: #e74c3c;
      margin-top: 15px;
    }
    .tools-section .clear-data-btn:hover {
      background: #c0392b;
    }
    .font-size-controls {
      margin-top: 0;
      padding-top: 0;
      border-top: none;
      margin-bottom: 15px;
      color: white;
      font-weight: bold;
    }
    .font-size-controls button {
      padding: 5px 10px;
      margin: 0 5px;
      background: #3498db;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-weight: normal;
      display: inline-block;
      width: auto;
      vertical-align: middle;
    }
    .font-size-controls button:hover {
      background: #2980b9;
    }
    .time-tracking {
      margin-top: 10px;
      font-size: 16px;
      color: #555;
      text-align: right;
    }
    .two-column-list {
      column-count: 2;
      column-gap: 20px;
      margin: 15px 0;
      padding: 0;
      list-style-type: disc;
      font-size: 16px;
    }
    .two-column-list li {
      margin-bottom: 10px;
      break-inside: avoid;
    }
    @media (max-width: 768px) {
      body {
        padding-left: 20px;
      }
      .sidebar {
        transform: translateX(-260px);
        width: 200px;
        padding-bottom: 20px;
        justify-content: flex-start;
      }
      body.sidebar-visible .sidebar {
        transform: translateX(0);
        z-index: 1000;
      }
      .sidebar.hidden {
        transform: translateX(-220px);
      }
      .toggle-btn {
        left: 15px;
        top: 15px;
      }
      body.sidebar-visible {
        padding-left: 220px;
      }
      .quiz-container {
        margin-top: 80px;
        padding: 20px;
      }
      .sidebar table {
        margin-bottom: 20px;
      }
      .tools-section {
        margin-bottom: 15px;
        padding-bottom: 10px;
      }
      .tools-section .button {
        width: 95%;
      }
      .font-size-controls {
        margin-bottom: 10px;
      }
      .font-size-controls label {
        display: inline-block;
        margin-right: 5px;
        color: white;
        font-weight: bold;
      }
      .two-column-list {
        column-count: 1;
      }
    }
    @media (min-width: 769px) {
      body.sidebar-visible {
        padding-left: 240px;
      }
      .sidebar.hidden + .quiz-container {
        margin-left: auto;
        margin-right: auto;
      }
    }
  </style>
</head>
<body>
  <div class="toggle-btn" onclick="toggleSidebar()"><span></span><span></span><span></span></div>
  <div class="sidebar" id="sidebar">
    <div class="tools-section">
      <h2>Tools</h2>
      <div class="font-size-controls">
        Font Size:
        <button onclick="changeFontSize(-2)">A-</button>
        <button onclick="changeFontSize(0)">A</button>
        <button onclick="changeFontSize(2)">A+</button>
      </div>
      <button class="button" onclick="shuffleQuestions()">Shuffle Questions</button>
      <button class="button" onclick="resetQuestionOrder()">Reset Question Order</button>
      <button class="button" onclick="shuffleOptions()">Shuffle Options</button>
      <button class="button theme-btn" onclick="toggleTheme()" id="theme-btn"><i class="fas fa-sun"></i> Toggle Theme</button>
      <button class="button fullscreen-btn" onclick="toggleFullscreen()" id="fullscreen-btn"><i class="fas fa-expand"></i> Toggle Fullscreen</button>
      <button class="button clear-data-btn" onclick="clearSavedData()">Clear Saved Data</button>
    </div>
    <h2>Questions</h2>
    <table id="questionTable"></table>
  </div>
  <div id="progress" style="text-align:center; margin: 10px 0; font-weight:bold;"></div>
  <div class="quiz-container">
    <div id="quiz-content"></div>
    <div class="time-tracking" id="time-tracking">समय: 0 सेकंड</div>
    <div class="navigation">
      <button onclick="prevQuestion()">Back</button>
      <button onclick="nextQuestion()">Next</button>
      <button onclick="submitQuiz()">Submit</button>
      <button onclick="reviewQuiz()">Review</button>
    </div>
    <div id="result"></div>
    <div id="score-summary" style="text-align:center; margin-top: 20px; font-size: 18px; font-weight: bold; color: #555;">
      सही उत्तर: 0 | गलत उत्तर: 0
    </div>
    <div id="completion-message" style="margin-top: 20px; text-align: center; font-size: 20px; font-weight: bold;"></div>
  </div>
  <script>
    let originalQuestions = [
{
question: 'विषय शीर्षक (सब्जेक्ट हेडिंग) निर्माण के लिए प्रयुक्त की जाने वाली विधियां है:',
options: ['सेयर्स लिस्ट ऑफ सब्जेक्ट हेडिंग', 'लाइब्रेरी ऑफ कांग्रेस सब्जेक्ट हेडिंग', 'श्रृंखला प्रक्रिया', 'उपरोक्त सभी'],
answer: 3,
explanation: 'विषय शीर्षक (Subject Heading) निर्माण के लिए कई विधियों का प्रयोग किया जाता है, जिनमें सेयर्स लिस्ट ऑफ सब्जेक्ट हेडिंग (Sears List of Subject Headings), लाइब्रेरी ऑफ कांग्रेस सब्जेक्ट हेडिंग (Library of Congress Subject Headings) और श्रृंखला प्रक्रिया (Chain Procedure) प्रमुख हैं। इसलिए, उपरोक्त सभी विकल्प सही हैं।'
},
{
question: 'विषय सूची का निर्माण किया जाता है:',
options: ['विषय अधिगम की पूर्ति के लिए', 'सूचीकार की संतुष्टि के लिए', 'पुस्तकालय को सजाने लिए', 'इनमें से कोई नहीं'],
answer: 0,
explanation: 'विषय सूची (Subject Catalogue) का निर्माण मुख्य रूप से उपयोगकर्ताओं की विषय अधिगम (Subject Access) की पूर्ति के लिए किया जाता है। यह उपयोगकर्ताओं को किसी विशेष विषय पर पुस्तकालय में उपलब्ध सामग्री को खोजने में मदद करता है।'
},
{
question: 'विषय शीर्षक (सब्जेक्ट हेडिंग) प्रतिनिधित्व करता है:',
options: ['पुस्तक के लेखक का', 'पुस्तक के संपूर्ण विषय का', 'प्रकाशन स्थान का', 'प्रकाशन वर्ष का'],
answer: 1,
explanation: 'विषय शीर्षक (Subject Heading) पुस्तक के संपूर्ण विषय का प्रतिनिधित्व करता है। यह एक या एक से अधिक शब्दों का समूह होता है जो पुस्तक की सामग्री के मुख्य विषय को दर्शाता है।'
},
{
question: 'विषय शीर्षक की निर्धारण की कितनी विधियां होती है:',
options: ['एक', 'दो', 'तीन', 'चार'],
answer: 1,
explanation: 'विषय शीर्षक के निर्धारण की मुख्य रूप से दो विधियां होती हैं: लिस्ट ऑफ सब्जेक्ट हेडिंग्स (जैसे LCSH, SLSH) और अनुक्रमणिकाण पद्धतियाँ (जैसे श्रृंखला प्रक्रिया, PRECIS, POPSI)।'
},
{
question: 'विषय शीर्षक (सब्जेक्ट हेडिंग) निर्धारण की दो विधियां होती है: लिस्ट ऑफ सब्जेक्ट हेडिंग्स एवं .',
options: ['श्रृंखला प्रक्रिया', 'POPSI', 'PRECIS', 'DDC'],
answer: 0,
explanation: 'विषय शीर्षक (Subject Heading) निर्धारण की दो मुख्य विधियां हैं: लिस्ट ऑफ सब्जेक्ट हेडिंग्स (जैसे LCSH, SLSH) और अनुक्रमणिकाण पद्धतियाँ, जिनमें श्रृंखला प्रक्रिया (Chain Procedure) एक प्रमुख विधि है।'
},
{
question: 'लाइब्रेरी ऑफ कांग्रेस सब्जेक्ट हेडिंग (LCSH) के प्रथम संस्करण का प्रकाशन कब किया गया था:',
options: ['1998 में', '1938 में', '1923 में', '1898 में'],
answer: 3,
explanation: 'लाइब्रेरी ऑफ कांग्रेस सब्जेक्ट हेडिंग (LCSH) के प्रथम संस्करण का प्रकाशन 1898 में किया गया था। यह अंग्रेजी भाषा में सबसे व्यापक रूप से उपयोग की जाने वाली विषय शीर्षक सूची में से एक है।'
},
{
question: 'लाइब्रेरी ऑफ कांग्रेस सब्जेक्ट हेडिंग को सर्वप्रथम दो खंडों में प्रकाशन किया गया था:',
options: ['1914 में', '1919 में', '2014 में', '1903 में'],
answer: 0,
explanation: 'लाइब्रेरी ऑफ कांग्रेस सब्जेक्ट हेडिंग (LCSH) को सर्वप्रथम 1914 में दो खंडों में प्रकाशित किया गया था। इसका उद्देश्य लाइब्रेरी ऑफ कांग्रेस के कैटलॉग के लिए एक मानकीकृत विषय शब्दावली प्रदान करना था।'
},
{
question: 'वर्तमान में लाइब्रेरी ऑफ कांग्रेस सब्जेक्ट हेडिंग का प्रकाशन किया जा रहा है:',
options: ['मुद्रित स्वरूप में', 'पीडीएफ स्वरूप में', 'ऑनलाइन स्वरूप में', 'पीडीएफ और ऑनलाइन दोनों स्वरूप में'],
answer: 3,
explanation: 'वर्तमान में लाइब्रेरी ऑफ कांग्रेस सब्जेक्ट हेडिंग (LCSH) का प्रकाशन पीडीएफ और ऑनलाइन दोनों स्वरूपों में किया जा रहा है। यह उपयोगकर्ताओं को विभिन्न माध्यमों से नवीनतम विषय शीर्षकों तक पहुँचने की सुविधा प्रदान करता है।'
},
{
question: 'लाइब्रेरी ऑफ कांग्रेस सब्जेक्ट हेडिंग में विषय शीर्षक कितने प्रकार के होते हैं:',
options: ['तीन प्रकार के', 'पाँच प्रकार के', 'दस प्रकार के', 'सोलह प्रकार के'],
answer: 1,
explanation: 'लाइब्रेरी ऑफ कांग्रेस सब्जेक्ट हेडिंग (LCSH) में मुख्य रूप से पाँच प्रकार के विषय शीर्षक होते हैं: टॉपिकल हेडिंग्स, फॉर्म हेडिंग्स, ज्योग्राफिक नेम्स, पर्सनल नेम्स, और कॉर्पोरेट नेम्स।'
},
{
question: 'बॉटनी किस तरह का यह शीर्षक है:',
options: ['सिंगल वर्ड हेडिंग', 'सिंगुलर प्लूरल हैडिंग', 'कंपलेक्स हेडिंग', 'इनमें से कोई नहीं'],
answer: 0,
explanation: 'बॉटनी (Botany) एक सिंगल वर्ड हेडिंग (एकल शब्द शीर्षक) का उदाहरण है, क्योंकि यह एक ही शब्द से बना एक विषय शीर्षक है।'
},
{
question: '"टीचर्स एज़ पॉलीटिशियन" किस तरह का शीर्षक है:',
options: ['संज्ञा सूचक शीर्षक', 'संयुक्त शब्द शीर्षक', 'एक ब्दात्मक शीर्षक', 'एक जटिल शीर्षक'],
answer: 0,
explanation: '"टीचर्स एज़ पॉलीटिशियन" (Teachers as Politicians) एक संज्ञा सूचक शीर्षक (Noun Phrase Heading) का उदाहरण है, क्योंकि यह एक वाक्यांश है जो संज्ञा से शुरू होता है और एक विषय को इंगित करता है।'
},
{
question: 'लाइब्रेरी ऑफ कांग्रेस सब्जेक्ट हेडिंग में क्लास नंबर किस वर्गीकरण पद्धति से लिखा जाता है:',
options: ['कोलोन क्लासिफिकेशन स्कीम', 'डेसिमल क्लासिफिकेशन स्कीम', 'यूनिवर्शल क्लासिफिकेशन स्कीम', 'लाइब्रेरी ऑफ कांग्रेस क्लासिफिकेशन स्कीम'],
answer: 3,
explanation: 'लाइब्रेरी ऑफ कांग्रेस सब्जेक्ट हेडिंग (LCSH) में क्लास नंबर लाइब्रेरी ऑफ कांग्रेस क्लासिफिकेशन स्कीम (Library of Congress Classification Scheme) से लिखे जाते हैं। LCSH और LCC दोनों लाइब्रेरी ऑफ कांग्रेस द्वारा विकसित और अनुरक्षित हैं।'
},
{
question: 'लाइब्रेरी ऑफ कांग्रेस सब्जेक्ट हेडिंग में USE का अर्थ होता है:',
options: ['यूज़ दिस हेडिंग', 'देखे', 'इसे भी देखें', 'इनमें से कोई नहीं'],
answer: 0,
explanation: 'लाइब्रेरी ऑफ कांग्रेस सब्जेक्ट हेडिंग (LCSH) में USE का अर्थ "Use this heading" (इस शीर्षक का प्रयोग करें) होता है। यह इंगित करता है कि इसके बजाय निर्दिष्ट पसंदीदा शीर्षक का उपयोग किया जाना चाहिए।'
},
{
question: 'लाइब्रेरी ऑफ कांग्रेस सब्जेक्ट हेडिंग में UF का अर्थ होता है:',
options: ['यूज़ दिस हेडिंग', 'यूज्ड फॉर', 'इसे भी देखें', 'इनमें से कोई नहीं'],
answer: 1,
explanation: 'लाइब्रेरी ऑफ कांग्रेस सब्जेक्ट हेडिंग (LCSH) में UF का अर्थ "Used For" (इसके लिए प्रयुक्त) होता है। यह इंगित करता है कि इसके सामने सूचीबद्ध अप्रचलित या गैर-पसंदीदा शीर्षक के बजाय वर्तमान शीर्षक का उपयोग किया जाता है।'
},
{
question: 'लाइब्रेरी ऑफ कांग्रेस सब्जेक्ट हेडिंग में BT का अर्थ होता है:',
options: ['यूज़ दिस हेडिंग', 'यूज्ड फॉर', 'बार्डर टॉपिक', 'ब्रॉड टेक्नालजी'],
answer: 2,
explanation: 'लाइब्रेरी ऑफ कांग्रेस सब्जेक्ट हेडिंग (LCSH) में BT का अर्थ "Broader Topic" (व्यापक विषय) होता है। यह इंगित करता है कि वर्तमान शीर्षक एक अधिक व्यापक विषय से संबंधित है।'
},
{
question: 'लाइब्रेरी ऑफ कांग्रेस सब्जेक्ट हेडिंग में NT का अर्थ होता है:',
options: ['नर्रोवर टॉपिक/टर्म (Narrower Topic)', 'नॉट फॉर टर्म', 'बार्डर टॉपिक', 'न्यू टॉपिक'],
answer: 0,
explanation: 'लाइब्रेरी ऑफ कांग्रेस सब्जेक्ट हेडिंग (LCSH) में NT का अर्थ "Narrower Topic/Term" (संकीर्ण विषय/पद) होता है। यह इंगित करता है कि सूचीबद्ध शीर्षक वर्तमान शीर्षक के तहत आने वाले अधिक विशिष्ट विषयों में से एक है।'
},
{
question: 'लाइब्रेरी ऑफ कांग्रेस सब्जेक्ट हेडिंग में RT का अर्थ होता है:',
options: ['रिलेटेड टॉपिक/टर्म', 'रोंग टर्म', 'राइट टर्म', 'ब्रॉड टेक्नालजी'],
answer: 0,
explanation: 'लाइब्रेरी ऑफ कांग्रेस सब्जेक्ट हेडिंग (LCSH) में RT का अर्थ "Related Topic/Term" (संबंधित विषय/पद) होता है। यह इंगित करता है कि सूचीबद्ध शीर्षक वर्तमान शीर्षक से संबंधित है, लेकिन न तो व्यापक है और न ही संकीर्ण।'
},
{
question: 'लाइब्रेरी ऑफ कांग्रेस सब्जेक्ट हेडिंग में SA का अर्थ होता है:',
options: ['सी आल्सो (See Also)', 'सी अगेन', 'सी एंड', 'सेयर्स एंड'],
answer: 0,
explanation: 'लाइब्रेरी ऑफ कांग्रेस सब्जेक्ट हेडिंग (LCSH) में SA का अर्थ "See Also" (इसे भी देखें) होता है। यह उपयोगकर्ताओं को संबंधित विषयों के लिए अन्य शीर्षकों को देखने के लिए निर्देशित करता है।'
},
{
question: 'लाइब्रेरी ऑफ कांग्रेस सब्जेक्ट हेडिंग में सब्जेक्ट हेडिंग में dash (-) किसको रिप्रेजेंट करता है:',
options: ['बोल्ड किए गए सब्जेक्ट हेडिंग के सब डिवीजन को', 'लेखक को', 'प्रकाशन वर्ष को', 'समानार्थी शब्द को'],
answer: 0,
explanation: 'लाइब्रेरी ऑफ कांग्रेस सब्जेक्ट हेडिंग (LCSH) में सब्जेक्ट हेडिंग में डैश (-) बोल्ड किए गए सब्जेक्ट हेडिंग के सबडिवीजन (उपविभाजन) को रिप्रेजेंट करता है। यह मुख्य विषय के अधिक विशिष्ट पहलुओं को इंगित करता है।'
},
{
question: 'लाइब्रेरी ऑफ कांग्रेस सब्जेक्ट हेडिंग किस तरह के पुस्तकालयों के लिए उपयोगी है:',
options: ['बड़े आकार के', 'छोटे आकार के', 'माध्यम आकार के', 'छोटे और माध्यम आकार के'],
answer: 0,
explanation: 'लाइब्रेरी ऑफ कांग्रेस सब्जेक्ट हेडिंग (LCSH) मुख्य रूप से बड़े आकार के पुस्तकालयों के लिए उपयोगी है, क्योंकि यह एक बहुत व्यापक और विस्तृत शब्दावली प्रदान करता है जिसके रखरखाव के लिए अधिक संसाधनों की आवश्यकता होती है।'
},
{
question: 'सेयर्स लिस्ट ऑफ सब्जेक्ट हेडिंग किस तरह के पुस्तकालयों के लिए उपयोगी है:',
options: ['बड़े आकार के', 'बहुत बड़े आकार के', 'माध्यम आकार के', 'छोटे और माध्यम आकार के'],
answer: 3,
explanation: 'सेयर्स लिस्ट ऑफ सब्जेक्ट हेडिंग (Sears List of Subject Headings) मुख्य रूप से छोटे और माध्यम आकार के पुस्तकालयों के लिए उपयोगी है। यह LCSH की तुलना में एक सरल और अधिक संक्षिप्त शब्दावली प्रदान करता है, जिससे यह छोटे संग्रह वाले पुस्तकालयों के लिए अधिक प्रबंधनीय हो जाता है।'
},
{
question: 'सेयर्स लिस्ट ऑफ सब्जेक्ट हेडिंग का प्रकाशन सर्वप्रथम किस वर्ष हुआ थाः',
options: ['1928', '1931', '1934', '1923'],
answer: 3,
explanation: 'सेयर्स लिस्ट ऑफ Subject हेडिंग (Sears List of Subject Headings) का प्रकाशन सर्वप्रथम 1923 में हुआ था। इसे मिनि अर्ल सेयर्स ने छोटे और माध्यम आकार के पुस्तकालयों की आवश्यकताओं को पूरा करने के लिए संकलित किया था।'
},
{
question: 'सेयर्स लिस्ट ऑफ सब्जेक्ट हेडिंग के निर्माता कौन हैं:',
options: ['Minnie Earl Sears', 'William Charles Berwick Sayers', 'S. R. Rangnathan', 'C. A. Cutter'],
answer: 0,
explanation: 'सेयर्स लिस्ट ऑफ सब्जेक्ट हेडिंग (Sears List of Subject Headings) के निर्माता Minnie Earl Sears हैं। उनके नाम पर ही इस सूची का नाम रखा गया है।'
},
{
question: 'सेयर्स लिस्ट ऑफ सब्जेक्ट हेडिंग का 2014 में 21वां संस्करण प्रकाशित हुआ जिसको प्रकाशित किया गया है:',
options: ['एच डब्ल्यू विल्सन पब्लिकेशन द्वारा', 'ओसीएलसी द्वारा', 'IFLA द्वारा', 'CILIP द्वारा'],
answer: 0,
explanation: 'सेयर्स लिस्ट ऑफ सब्जेक्ट हेडिंग का 2014 में 21वां संस्करण एच डब्ल्यू विल्सन पब्लिकेशन (H.W. Wilson Publication) द्वारा प्रकाशित किया गया था। H.W. Wilson पुस्तकालय और सूचना विज्ञान से संबंधित प्रकाशनों के लिए जाना जाता है।'
},
{
question: 'वर्तमान में सेयर्स लिस्ट ऑफ सब्जेक्ट हेडिंग का प्रकाशन किया जा रहा है:',
options: ['मुद्रित स्वरूप में', 'पीडीएफ स्वरूप में', 'ऑनलाइन स्वरूप में', 'पीडीएफ और ऑनलाइन दोनों स्वरूप में'],
answer: 3,
explanation: 'वर्तमान में सेयर्स लिस्ट ऑफ सब्जेक्ट हेडिंग (Sears List of Subject Headings) का प्रकाशन पीडीएफ और ऑनलाइन दोनों स्वरूपों में किया जा रहा है, जिससे यह विभिन्न प्रकार के पुस्तकालयों और उपयोगकर्ताओं के लिए सुलभ हो सके।'
},
{
question: 'सेयर्स लिस्ट ऑफ सब्जेक्ट हेडिंग में विषय के प्रस्तुतीकरण के लिए प्रयोग किया गया है:',
options: ['बड़े और गहरे अक्षरों का', 'बड़े पर हल्के अक्षरों का', 'छोटे और गहरे अक्षरों का', 'छोटे और हल्के अक्षरों का'],
answer: 0,
explanation: 'सेयर्स लिस्ट ऑफ सब्जेक्ट हेडिंग (Sears List of Subject Headings) में विषय के प्रस्तुतीकरण के लिए बड़े और गहरे अक्षरों (Bold font) का प्रयोग किया गया है ताकि वे आसानी से पहचाने जा सकें।'
},
{
question: 'सेयर्स लिस्ट ऑफ सब्जेक्ट हेडिंग में शीर्षक के पर्यायवाचीओं के लिए प्रयोग किया गया है:',
options: ['बड़े और गहरे अक्षरों का', 'बड़े पर हल्के अक्षरों का', 'छोटे और गहरे अक्षरों का', 'छोटे और हल्के अक्षरों का'],
answer: 3,
explanation: 'सेयर्स लिस्ट ऑफ सब्जेक्ट हेडिंग (Sears List of Subject Headings) में शीर्षक के पर्यायवाचीओं (Synonyms) के लिए छोटे और हल्के अक्षरों का प्रयोग किया गया है और उन्हें \'x\' या \'used for\' से दर्शाया गया है, जो इंगित करता है कि इन पदों का उपयोग मुख्य शीर्षक के बजाय किया जाता है।'
},
{
question: 'लाइब्रेरी ऑफ कांग्रेस सब्जेक्ट हेडिंग में X का अर्थ होता है:',
options: ['सी (See)', 'सेवेन', 'सब्जेक्ट', 'सेयर्स एंड'],
answer: 0,
explanation: 'लाइब्रेरी ऑफ कांग्रेस सब्जेक्ट हेडिंग (LCSH) में X का अर्थ "See" (देखें) होता है। यह इंगित करता है कि उपयोगकर्ता को सूचीबद्ध शीर्षक के बजाय किसी अन्य शीर्षक को देखना चाहिए।'
},
{
question: 'लाइब्रेरी ऑफ कांग्रेस सब्जेक्ट हेडिंग में XX का अर्थ होता है:',
options: ['सी आल्सो (See Also)', 'सी अगेन', 'सी एंड', 'सेयर्स एंड'],
answer: 0,
explanation: 'लाइब्रेरी ऑफ कांग्रेस सब्जेक्ट हेडिंग (LCSH) में XX का अर्थ "See Also" (इसे भी देखें) होता है। यह उपयोगकर्ताओं को संबंधित विषयों के लिए अन्य शीर्षकों को देखने के लिए निर्देशित करता है।'
},
{
question: 'श्रृंखला प्रक्रिया के प्रणेता कौन है:',
options: ['सी ए कटर', 'रिचर्डसन', 'डॉ एस आर रंगनाथन', 'सेयर्स महोदय'],
answer: 2,
explanation: 'श्रृंखला प्रक्रिया (Chain Procedure) के प्रणेता डॉ. एस. आर. रंगनाथन हैं। उन्होंने इस अनुक्रमणिका तकनीक का विकास क्लासीफाइड कैटलॉग कोड (CCC) के लिए किया था।'
},
{
question: 'श्रृंखला प्रक्रिया का विकास किस सूचीकरण पद्धति के लिए किया गया थाः',
options: ['सीसीसी', 'एएसीआर-2', 'एएसीआर-3', 'एएसीआर-2 आर'],
answer: 0,
explanation: 'श्रृंखला प्रक्रिया (Chain Procedure) का विकास क्लासीफाइड कैटलॉग कोड (CCC) के लिए किया गया था। इसका उद्देश्य CCC में वर्गीकृत भाग के लिए विषय अनुक्रमणिका प्रविष्टियाँ तैयार करना था।'
},
{
question: 'श्रृंखला प्रक्रिया का विकास किस वर्ष किया गया थाः',
options: ['1934 में', '1933 में', '1938 में', '1939 में'],
answer: 2,
explanation: 'श्रृंखला प्रक्रिया (Chain Procedure) का विकास 1938 में डॉ. एस. आर. रंगनाथन द्वारा किया गया था, और इसे उनकी पुस्तक "Theory of Library Catalogue" में पहली बार प्रस्तुत किया गया।'
},
{
question: 'क्या श्रृंखला प्रक्रिया का विकास CCC के प्रथम संस्करण के साथ हुआ था?',
options: ['नहीं', 'हाँ', 'स्पष्ट नहीं है', 'इनमें से कोई नहीं'],
answer: 0,
explanation: 'नहीं, श्रृंखला प्रक्रिया का विकास CCC के प्रथम संस्करण के साथ नहीं हुआ था। CCC का प्रथम संस्करण 1934 में प्रकाशित हुआ था, जबकि श्रृंखला प्रक्रिया का विकास 1938 में हुआ था और इसे CCC के बाद के संस्करणों में शामिल किया गया।'
},
{
question: 'विषय सूची का निर्माण किसके लिए किया जाता है:',
options: ['सामान्य पाठकों के लिए', 'विशिष्ट पाठकों के लिए', 'कर्मचारियों के लिए', 'अधिकारियों के लिए'],
answer: 1,
explanation: 'विषय सूची (Subject Catalogue) का निर्माण मुख्य रूप से विशिष्ट पाठकों (Specialized users) के लिए किया जाता है, जो किसी विशेष विषय पर गहराई से जानकारी चाहते हैं।'
},
{
question: 'विषय सूची का निर्माण किया जाता है:',
options: ['पाठकों के सामान्य अधिगम की पूर्ति के लिए', 'शीर्षक से संबन्धित कार्य के लिए', 'पाठकों के विषय अधिगम की पूर्ति के लिए', 'लेखक की जानकारी के लिए'],
answer: 2,
explanation: 'विषय सूची का निर्माण पाठकों के विषय अधिगम (Subject Access) की पूर्ति के लिए किया जाता है। यह उपयोगकर्ताओं को उनके रुचि के विषय पर आधारित सामग्री खोजने में सक्षम बनाता है।'
},
{
question: 'श्रृंखला प्रक्रिया का विकास किस पुस्तक में किया गया थाः',
options: ['थ्योरी ऑफ कैटलॉग', 'सीसीसी', 'सीसी', 'फाइव लॉ ऑफ लाइब्रेरी साइंस'],
answer: 0,
explanation: 'श्रृंखला प्रक्रिया (Chain Procedure) का विकास डॉ. एस. आर. रंगनाथन की पुस्तक "Theory of Library Catalogue" में किया गया था, जो 1938 में प्रकाशित हुई थी।'
},
{
question: 'श्रृंखला प्रक्रिया में सब्जेक्ट का निर्धारण किसके द्वारा किया जाता है:',
options: ['क्लास नंबर (Class No.) से', 'Acc No से', 'बूक नंबर से', 'कटर नंबर से'],
answer: 0,
explanation: 'श्रृंखला प्रक्रिया (Chain Procedure) में सब्जेक्ट का निर्धारण क्लास नंबर (Class Number) से किया जाता है। क्लास नंबर के प्रत्येक अंक या घटक को एक कड़ी माना जाता है, और इन कड़ियों से विषय शीर्षक व्युत्पन्न किए जाते हैं।'
},
{
question: 'श्रृंखला प्रक्रिया में कितने प्रकार के कड़ियों का वर्णन है:',
options: ['4', '14', '43', '9'],
answer: 0,
explanation: 'श्रृंखला प्रक्रिया (Chain Procedure) में मुख्य रूप से चार प्रकार के कड़ियों का वर्णन है: वांछित कड़ी (Sought Link), अवांछित कड़ी (Unsought Link), मिथ्या कड़ी (False Link) और लुप्त कड़ी (Missing Link)।'
},
{
question: 'PRECIS का निर्माण किस वर्ष हुआ थाः',
options: ['1969 में', '1968 में', '1961 में', '1963 में'],
answer: 0,
explanation: 'PRECIS (Preserved Context Index System) का निर्माण 1969 में डेरेक ऑस्टिन द्वारा किया गया था। यह एक अनुक्रमणिका प्रणाली है जिसे ब्रिटिश नेशनल बिब्लियोग्राफी (BNB) के लिए विकसित किया गया था।'
},
{
question: 'PRECIS का प्रथम प्रकाशन किस वर्ष हुआ थाः',
options: ['1971 में', '1974 में', '1960 में', '1933 में'],
answer: 0,
explanation: 'PRECIS (Preserved Context Index System) का प्रथम प्रकाशन 1971 में ब्रिटिश नेशनल बिब्लियोग्राफी (BNB) में हुआ था, जहाँ इसे श्रृंखला प्रक्रिया के स्थान पर अपनाया गया था।'
},
{
question: 'PRECIS का निर्माण निम्नलिखित में किस अनुक्रमणिका बनाने के लिए किया जाता है:',
options: ['बीएनबी', 'आईएनबी', 'दोनों', 'इनमें से कोई नहीं'],
answer: 0,
explanation: 'PRECIS (Preserved Context Index System) का निर्माण मुख्य रूप से ब्रिटिश नेशनल बिब्लियोग्राफी (BNB) के लिए अनुक्रमणिका बनाने के लिए किया जाता है। इसे BNB की विषय अनुक्रमणिका के रूप में इस्तेमाल किया गया था।'
},
{
question: 'PRECIS का निर्माण से पूर्व बीएनबी के लिए प्रयोग किया जाता थाः',
options: ['श्रृंखला प्रक्रिया', 'POPSI', 'KWIC', 'इनमें से कोई नहीं'],
answer: 0,
explanation: 'PRECIS का निर्माण से पूर्व ब्रिटिश नेशनल बिब्लियोग्राफी (BNB) के लिए श्रृंखला प्रक्रिया (Chain Procedure) का प्रयोग किया जाता था। PRECIS ने BNB में श्रृंखला प्रक्रिया का स्थान लिया।'
},
{
question: 'रोल ऑपरेटर का प्रयोग किस पद्धति में किया जाता थाः',
options: ['PRECIS', 'POPSI', 'KWIC', 'इनमें से कोई नहीं'],
answer: 0,
explanation: 'रोल ऑपरेटर (Role Operators) का प्रयोग PRECIS (Preserved Context Index System) पद्धति में किया जाता है। ये ऑपरेटर इंडेक्स स्ट्रिंग में पदों के वाक्यात्मक संबंध को इंगित करते हैं।'
},
{
question: 'PRECIS में Location के लिए प्राइमरी रोल ऑपरेटर के लिए यूज किया जाता है:',
options: ['जीरो (0)', 'तीन', 'डॉट', 'डैश'],
answer: 0,
explanation: 'PRECIS (Preserved Context Index System) में Location (स्थान) के लिए प्राइमरी रोल ऑपरेटर के रूप में जीरो (0) का प्रयोग किया जाता है।'
},
{
question: 'PRECIS में Form of Document के लिए प्राइमरी रोल ऑपरेटर के लिए यूज किया जाता है:',
options: ['जीरो', 'तीन', 'डॉट', 'सिक्स (6)'],
answer: 3,
explanation: 'PRECIS (Preserved Context Index System) में Form of Document (दस्तावेज़ का रूप) के लिए प्राइमरी रोल ऑपरेटर के रूप में सिक्स (6) का प्रयोग किया जाता है।'
},
{
question: 'POPSI के निर्माण का श्रेय किसको है:',
options: ['गणेश भट्टाचार्य को', 'निलमेघनन को', 'रंगनाथन को', 'डेरेक ऑस्टिन को'],
answer: 0,
explanation: 'POPSI (Postulate-based Permuted Subject Indexing) के निर्माण का श्रेय गणेश भट्टाचार्य को है। उन्होंने इस अनुक्रमणिका प्रणाली का विकास डॉ. एस. आर. रंगनाथन के विचारों पर आधारित किया।'
},
{
question: 'POPSI का निर्माण किस संस्था द्वारा किया गया था:',
options: ['डीआरटीसी (DRTC)', 'IASLIC', 'SERLS', 'CILIP'],
answer: 0,
explanation: 'POPSI (Postulate-based Permuted Subject Indexing) का निर्माण डीआरटीसी (DRTC - Documentation Research and Training Centre) द्वारा किया गया था। यह बैंगलोर, भारत में स्थित एक प्रमुख अनुसंधान और प्रशिक्षण केंद्र है।'
},
{
question: 'POPSI किस वर्गीकरण पद्धति पर आधारित है:',
options: ['द्विबिन्दु वर्गीकरण पद्धति पर', 'दशमलव वर्गीकरण पद्धति पर', 'विस्तार वर्गीकरण पद्धति पर', 'किसी वर्गीकरण पद्धति पर नहीं'],
answer: 3,
explanation: 'POPSI (Postulate-based Permuted Subject Indexing) किसी विशिष्ट वर्गीकरण पद्धति पर आधारित नहीं है। यह विषयों के विश्लेषण और अनुक्रमणिका स्ट्रिंग के निर्माण के लिए अपने स्वयं के सिद्धांतों और प्रतिमानों का उपयोग करता है, हालांकि यह रंगनाथन के विचारों से प्रभावित है।'
},
{
question: 'POPSI विषयों का विश्लेषण हेतु कितने प्रारंभिक श्रेणियों की अवधारणा पर आधारित है:',
options: ['4 प्रारंभिक श्रेणी की अवधारणा', '3 प्रारंभिक श्रेणी की अवधारणा', '2 प्रारंभिक श्रेणी की अवधारणा', '5 प्रारंभिक श्रेणी की अवधारणा'],
answer: 3,
explanation: 'POPSI (Postulate-based Permuted Subject Indexing) विषयों का विश्लेषण हेतु 5 प्रारंभिक श्रेणियों की अवधारणा पर आधारित है। ये श्रेणियाँ Discipline, Entity, Action, Property और Modifier हैं।'
},
{
question: 'पॉप्सी विधि में मुख्यतः दो प्रकार की प्रक्रिया होती है पहला प्रलेख की अवधारणाओं और सिद्धांत के आधार पर निरूपित करना और दूसरा निरूपित विषय में निहित पदों का करना।',
options: ['क्रम परिवर्तन', 'विश्लेषण', 'क्रम निर्धारण', 'क्रम विश्लेषण'],
answer: 0,
explanation: 'पॉप्सी विधि में मुख्यतः दो प्रकार की प्रक्रिया होती है: पहला प्रलेख की अवधारणाओं और सिद्धांत के आधार पर विषय को निरूपित करना, और दूसरा निरूपित विषय में निहित पदों का क्रम परिवर्तन (Permutation) कर प्रविष्टि का निर्माण करना। क्रम परिवर्तन से विभिन्न पहुँच बिंदु प्राप्त होते हैं।'
},
{
question: 'पॉप्सी की अवधारणा को निरूपित करने के लिए 5 प्रारंभिक श्रेणी की अवधारणा की गई है, डिसिप्लिन, इनटीटी, ऑक्शन, प्रॉपर्टी और',
options: ['मैटर', 'फॉर्म', 'डिजिट', 'मोडीफायर'],
answer: 3,
explanation: 'पॉप्सी (POPSI) की अवधारणा को निरूपित करने के लिए 5 प्रारंभिक श्रेणियां हैं: Discipline (D), Entity (E), Action (A), Property (P), और Modifier (M)। इसलिए, अंतिम श्रेणी Modifier है।'
},
{
question: 'पॉप्सी की प्रारंभिक श्रेणी की अवधारणा में \'D\' का अर्थ होता है:',
options: ['Data', 'Digital', 'Discipline', 'Draft'],
answer: 2,
explanation: 'पॉप्सी (POPSI) की प्रारंभिक श्रेणी की अवधारणा में \'D\' का अर्थ Discipline (अनुशासन) होता है। यह विषय के अध्ययन के क्षेत्र को इंगित करता है।'
},
{
question: 'पॉप्सी की प्रारंभिक श्रेणी की अवधारणा में \'E\' का अर्थ होता है:',
options: ['Energy', 'Education', 'Entity', 'इनमें से कोई नहीं'],
answer: 2,
explanation: 'पॉप्सी (POPSI) की प्रारंभिक श्रेणी की अवधारणा में \'E\' का अर्थ Entity (इकाई) होता है। यह किसी वस्तु, व्यक्ति या अवधारणा को संदर्भित करता है जिस पर Action किया जाता है।'
},
{
question: 'पॉप्सी की प्रारंभिक श्रेणी की अवधारणा में \'A\' का अर्थ होता है:',
options: ['And', 'Action', 'American', 'Anchor'],
answer: 1,
explanation: 'पॉप्सी (POPSI) की प्रारंभिक श्रेणी की अवधारणा में \'A\' का अर्थ Action (क्रिया) होता है। यह Entity पर की गई गतिविधि या प्रक्रिया को इंगित करता है।'
},
{
question: 'पॉप्सी की प्रारंभिक श्रेणी की अवधारणा में \'P\' का अर्थ होता है:',
options: ['Personality', 'Plane', 'Property', 'Person'],
answer: 2,
explanation: 'पॉप्सी (POPSI) की प्रारंभिक श्रेणी की अवधारणा में \'P\' का अर्थ Property (गुण) होता है। यह Entity या Action की विशेषता को दर्शाता है।'
},
{
question: 'पॉप्सी की प्रारंभिक श्रेणी की अवधारणा में \'M\' का अर्थ होता है:',
options: ['Matter', 'Mode', 'Midifier', 'Month'],
answer: 2,
explanation: 'पॉप्सी (POPSI) की प्रारंभिक श्रेणी की अवधारणा में \'M\' का अर्थ Modifier (संशोधक) होता है। यह किसी अन्य प्रारंभिक श्रेणी के लिए अतिरिक्त विशेषताएँ प्रदान करता है।'
},
{
question: 'कंपास (COMPASS) निम्न में से किस का नवीनतम स्वरूप है:',
options: ['POPSI', 'KWIC', 'PRECIS', 'Chain Index'],
answer: 2,
explanation: 'कंपास (COMPASS - Computer Aided Subject System) PRECIS (Preserved Context Index System) का नवीनतम स्वरूप है। इसे ब्रिटिश लाइब्रेरी द्वारा PRECIS के स्थान पर विकसित किया गया था।'
},
{
question: 'कंपास (COMPASS) प्रणाली का विकास किस वर्ष किया गया था:',
options: ['1888', '1978', '2022', '1991'],
answer: 3,
explanation: 'कंपास (COMPASS) प्रणाली का विकास 1991 में किया गया था। इसे ब्रिटिश नेशनल बिब्लियोग्राफी (BNB) के लिए अनुक्रमणिका बनाने के लिए उपयोग किया गया था।'
},
{
question: 'COMPASS का पूरा नाम है :',
options: ['Computer Systen Index', 'Computer Aided Subject Systen', 'Computer Analysis Systen', 'Computer And System'],
answer: 1,
explanation: 'COMPASS का पूरा नाम Computer Aided Subject System है। यह एक कम्प्यूटरीकृत अनुक्रमणिका प्रणाली है जो विषय शीर्षकों के निर्माण में सहायता करती है।'
},
{
question: 'किस वर्ष कंपास नें PRECIS को रिप्लेस कर दिया:',
options: ['2002', '1978', '2022', '1991'],
answer: 3,
explanation: 'कंपास (COMPASS) ने 1991 में ब्रिटिश नेशनल बिब्लियोग्राफी (BNB) में PRECIS (Preserved Context Index System) को रिप्लेस कर दिया था।'
},
{
question: 'कीवर्ड इंडेक्सिंग (KWIC) का विकास किसके द्वारा किया गया था:',
options: ['S. R. Ranganathan', 'H. P. Luhan', 'Kaiser', 'Shepherd'],
answer: 1,
explanation: 'कीवर्ड इंडेक्सिंग (KWIC - Keyword in Context) का विकास H. P. Luhn द्वारा किया गया था। यह एक स्वचालित अनुक्रमणिका तकनीक है जो शीर्षक में महत्वपूर्ण शब्दों का उपयोग करती है।'
},
{
question: 'कीवर्ड इंडेक्सिंग (KWIC) का विकास किस वर्ष किया गया थाः',
options: ['1969', '1958', '1984', '1991'],
answer: 1,
explanation: 'कीवर्ड इंडेक्सिंग (KWIC) का विकास 1958 में H. P. Luhn द्वारा किया गया था। यह शुरुआती कम्प्यूटरीकृत अनुक्रमणिका तकनीकों में से एक थी।'
},
{
question: 'कीवर्ड इंडेक्सिंग (KWIC) किस को आधार बनाया गया है:',
options: ['Author', 'Keyword', 'Title', 'Subject'],
answer: 2,
explanation: 'कीवर्ड इंडेक्सिंग (KWIC) Title (शीर्षक) को आधार बनाया गया है। यह शीर्षक में दिखाई देने वाले महत्वपूर्ण शब्दों (कीवर्ड) का उपयोग करके अनुक्रमणिका प्रविष्टियाँ बनाता है।'
},
{
question: 'Uniterm Indexing का विकास किसके द्वारा किया गया था:',
options: ['Mortimer Taube', 'H. P. Luhan', 'Kaiser', 'Shepherd'],
answer: 0,
explanation: 'Uniterm Indexing का विकास Mortimer Taube द्वारा किया गया था। यह एक पोस्ट-कोऑर्डिनेट इंडेक्सिंग प्रणाली है जो एकल शब्दों (यूनिटर्म्स) का उपयोग करती है।'
},
{
question: 'Uniterm Indexing का विकास किस वर्ष किया गया थाः',
options: ['1953', '1958', '1984', '1991'],
answer: 0,
explanation: 'Uniterm Indexing का विकास 1953 में Mortimer Taube द्वारा किया गया था। यह दस्तावेज़ पुनर्प्राप्ति के लिए एक सरल और प्रभावी विधि थी।'
},
{
question: 'Uniterm Indexing प्रणाली में एक अवधारणा के लिए कितने पदों का प्रयोग किया जाता है:',
options: ['एक पद', 'तीन पद', 'चार पद', 'पाँच पद'],
answer: 0,
explanation: 'Uniterm Indexing प्रणाली में एक अवधारणा के लिए एक पद (Uniterm) का प्रयोग किया जाता है। जटिल विषयों को कई यूनिटर्म्स के संयोजन से दर्शाया जाता है।'
},
{
question: 'Uniterm Indexing प्रणाली में किस वर्गीकरण पद्धति की आवश्यकता होती है:',
options: ['द्विबिन्दु वर्गीकरण पद्धति', 'दशमलव वर्गीकरण पद्धति', 'विस्तार वर्गीकरण पद्धति', 'किसी वर्गीकरण पद्धति की नहीं'],
answer: 3,
explanation: 'Uniterm Indexing प्रणाली में किसी विशिष्ट वर्गीकरण पद्धति की आवश्यकता नहीं होती है। यह सीधे दस्तावेज़ों से निकाले गए शब्दों (यूनिटर्म्स) पर आधारित है।'
},
{
question: 'Citation इंडेक्सिंग का विकास किसके द्वारा किया गया थाः',
options: ['Mortimer Taube', 'H. P. Luhan', 'Kaiser', 'Eugine Garfield'],
answer: 3,
explanation: 'Citation Indexing (उद्धरण अनुक्रमणिका) का विकास Eugine Garfield द्वारा किया गया था। यह एक अनुक्रमणिका विधि है जो वैज्ञानिक साहित्य में उद्धरण संबंधों का विश्लेषण करती है।'
},
{
question: 'Citation Indexing का विकास किस वर्ष किया गया थाः',
options: ['1963', '1958', '1984', '1991'],
answer: 0,
explanation: 'Citation Indexing का विकास 1963 में Eugine Garfield द्वारा किया गया था जब उन्होंने Science Citation Index (SCI) की स्थापना की थी।'
},
{
question: 'Citation Index का विकास सर्वप्रथम किसके द्वारा किया गया था:',
options: ['Mortimer Taube', 'H. P. Luhan', 'Kaiser', 'Eugine Garfield'],
answer: 3,
explanation: 'Citation Index (उद्धरण अनुक्रमणिका) का विकास सर्वप्रथम Eugine Garfield द्वारा किया गया था। उन्होंने इस अवधारणा को वैज्ञानिक संचार के विश्लेषण के लिए एक उपकरण के रूप में विकसित किया।'
},
{
question: 'Eugine Garfield महोदय का Citation Indexing प्रणाली किस पर आधारित है:',
options: ['Mortimer Taube', 'H. P. Luhan', 'Kaiser', 'Shepherd महोदय के Citation Index पर'],
answer: 3,
explanation: 'Eugine Garfield महोदय का Citation Indexing प्रणाली Shepherd महोदय के Citation Index पर आधारित नहीं है, बल्कि यह Eugine Garfield द्वारा स्वयं विकसित एक अवधारणा है जो वैज्ञानिक साहित्य में उद्धरणों के विश्लेषण पर केंद्रित है।'
},
{
question: 'शब्दावली नियंत्रण की आवश्यकता इसलिए है क्योंकि प्राकृतिक भाषा में कई पर्यायवाची और समनाम शब्द होते हैं जो -',
options: ['खोज को प्रभावित करते हैं', 'पाठक के विचारों को प्रभावित करते हैं', 'पुस्तक के क्रम को प्रभावित करते हैं', 'इनमें से कोई नहीं'],
answer: 0,
explanation: 'शब्दावली नियंत्रण (Vocabulary Control) की आवश्यकता इसलिए है क्योंकि प्राकृतिक भाषा में कई पर्यायवाची (Synonyms) और समनाम (Homonyms) शब्द होते हैं जो सूचना पुनर्प्राप्ति में खोज को प्रभावित करते हैं। शब्दावली नियंत्रण एक मानकीकृत शब्दावली का उपयोग करके इस समस्या को हल करने का प्रयास करता है।'
},
{
question: 'सूचना पुनर्प्राप्ति शब्द का सर्वप्रथम प्रयोग केल्विन मूर्स द्वारा किस वर्ष किया गया थाः',
options: ['1950 में', '1960 में', '1966 में', '1991 में'],
answer: 0,
explanation: 'सूचना पुनर्प्राप्ति (Information Retrieval) शब्द का सर्वप्रथम प्रयोग केल्विन मूर्स (Calvin Mooers) द्वारा 1950 में किया गया था। यह शब्द जानकारी खोजने और पुनः प्राप्त करने की प्रक्रिया को संदर्भित करता है।'
},
{
question: 'रोल ऑपरेटर का प्रावधान किस तरह की इंडेक्सिंग पद्धति में है:',
options: ['PRECIS', 'POPSI', 'Chain Index', 'KWIC'],
answer: 0,
explanation: 'रोल ऑपरेटर (Role Operators) का प्रावधान PRECIS (Preserved Context Index System) इंडेक्सिंग पद्धति में है। ये ऑपरेटर इंडेक्स स्ट्रिंग में पदों के बीच वाक्यात्मक संबंधों को स्पष्ट करते हैं।'
},
{
question: '1969 ई. में किसके द्वारा सूचना पुनर्प्रप्ति के क्षेत्र में Thesaurus का प्रयोग किया गया है:',
options: ['Shepherd', 'Aitchinson.', 'Du Pont', 'Ranganathan'],
answer: 2,
explanation: '1969 ई. में Du Pont द्वारा सूचना पुनर्प्राप्ति के क्षेत्र में Thesaurus का प्रयोग किया गया है। थिसॉरस संबंधित शब्दों के बीच शब्दार्थ संबंधों को दर्शाता है और खोज सटीकता में सुधार करने में मदद करता है।'
},
{
question: 'Thesaurofecet शब्द का प्रयोग किसने किया है:',
options: ['Shepherd', 'Jean Aitchinson', 'Du Pont', 'Ranganathan'],
answer: 1,
explanation: 'Thesaurofacet शब्द का प्रयोग Jean Aitchinson द्वारा किया गया है। यह एक अनुक्रमणिका भाषा है जो एक थिसॉरस और एक फेसेटेड वर्गीकरण योजना के सिद्धांतों को जोड़ती है।'
},
{
question: 'Thesaurofecet शब्द का प्रयोग कब किया गया :',
options: ['1955', '1969', '1960', '1995'],
answer: 1,
explanation: 'Thesaurofacet शब्द का प्रयोग 1969 में Jean Aitchinson द्वारा किया गया था जब उन्होंने Thesaurofacet अनुक्रमणिका भाषा विकसित की थी।'
},
{
question: 'Thesaurofecet का प्रयोग किया जाता है :',
options: ['फेसेटेड वर्गीकरण पद्धति की विशेषताओं का सम्मिलित उपयोग के लिए', 'फेसेटेड वर्गीकरण पद्धति और थिसॉरस की विशेषताओं का सम्मिलित उपयोग के लिए', 'थिसॉरस की विशेषताओं का सम्मिलित उपयोग के लिए', 'ग्रंथसूची और थिसॉरस की विशेषताओं का सम्मिलित उपयोग के लिए'],
answer: 1,
explanation: 'Thesaurofacet का प्रयोग फेसेटेड वर्गीकरण पद्धति (Faceted Classification) और थिसॉरस (Thesaurus) की विशेषताओं का सम्मिलित उपयोग करने के लिए किया जाता है। यह विषयों को व्यवस्थित करने और जानकारी खोजने के लिए एक शक्तिशाली उपकरण प्रदान करता है।'
},
{
question: '\'Precision\' और \'Recall\' शब्द निम्नलिखित में से किससे जुड़ा हुआ है:',
options: ['ग्रंथपरक विवरण', 'सूचीकरण के सिद्धान्त', 'ऑनलाइन वर्गीकरण', 'सूचना पुनर्प्राप्ति'],
answer: 3,
explanation: '\'Precision\' और \'Recall\' शब्द सूचना पुनर्प्राप्ति (Information Retrieval) के मूल्यांकन से जुड़ा हुआ है। प्रेसिजन पुनर्प्राप्त किए गए प्रासंगिक दस्तावेजों का अनुपात बताता है, जबकि रिकॉल प्रणाली द्वारा पुनर्प्राप्त कुल प्रासंगिक दस्तावेजों का अनुपात बताता है।'
},
{
question: 'सूचना पुनर्प्राप्ति (Information retrieval) के क्षेत्र में \'Recall\' शब्द का अर्थ है:',
options: ['डेटाबेस में प्रासंगिक रिकॉर्ड की कुल संख्या के लिए पुनर्प्राप्त प्रासंगिक रिकॉर्ड की संख्या का अनुपात', 'डेटाबेस में प्रासंगिक रिकॉर्ड की कुल संख्या', 'डेटाबेस में रिकॉर्ड की कुल संख्या', 'डेटाबेस में अप्रासंगिक रिकॉर्ड की कुल संख्या'],
answer: 0,
explanation: 'सूचना पुनर्प्राप्ति (Information Retrieval) के क्षेत्र में \'Recall\' का अर्थ है, डेटाबेस में मौजूद कुल प्रासंगिक रिकॉर्ड में से कितने रिकॉर्ड पुनर्प्राप्त किए गए। यह पुनर्प्राप्ति प्रणाली की पूर्णता का एक माप है।'
},
{
question: 'सूचना पुनर्प्राप्ति (Information retrieval) के क्षेत्र में \'Precision\' शब्द का अर्थ है:',
options: ['पुनर्प्राप्त किए गए प्रासंगिक रिकॉर्ड की संख्या और पुनर्प्राप्त किए गए अप्रासंगिक और प्रासंगिक रिकॉर्ड की कुल संख्या का अनुपात', 'डेटाबेस में प्रासंगिक रिकॉर्ड की कुल संख्या', 'डेटाबेस में अप्रासंगिक रिकॉर्ड की कुल संख्या', 'इनमें से कोई नहीं'],
answer: 0,
explanation: 'सूचना पुनर्प्राप्ति (Information Retrieval) के क्षेत्र में \'Precision\' का अर्थ है, पुनर्प्राप्त किए गए कुल रिकॉर्ड में से कितने रिकॉर्ड वास्तव में प्रासंगिक थे। यह पुनर्प्राप्ति प्रणाली की सटीकता का एक माप है।'
},
{
question: 'बूलियन खोज 19वीं सदी में अंग्रेजी गणितज्ञ द्वारा विकसित प्रतीकात्मक तर्क की एक पद्धति पर बनाई गई है।',
options: ['George Boole', 'KelvinMoors', 'Paul Otlet', 'Belkin'],
answer: 0,
explanation: 'बूलियन खोज (Boolean Search) 19वीं सदी में अंग्रेजी गणितज्ञ George Boole द्वारा विकसित प्रतीकात्मक तर्क की एक पद्धति पर आधारित है। बूलियन लॉजिक सेट के संचालन के आधार पर काम करता है और सूचना पुनर्प्राप्ति में इसका व्यापक रूप से उपयोग किया जाता है।'
},
{
question: 'बूलियन खोज आपको अपनी खोज को सीमित करने, विस्तृत करने या परिभाषित करने के लिए, बूलियन ऑपरेटर के रूप में किन शब्दों का उपयोग करके शब्दों और वाक्यांशों को संयोजित करने की अनुमति देती है।',
options: ['AND, OR, Zero', 'AND, OR, NOT', 'AND, All, NOT', 'AND, OR, All'],
answer: 1,
explanation: 'बूलियन खोज में, AND, OR, और NOT जैसे बूलियन ऑपरेटर का उपयोग शब्दों और वाक्यांशों को संयोजित करने के लिए किया जाता है। AND शब्दों के संयोजन वाले परिणाम ढूंढता है, OR किसी भी शब्द वाले परिणाम ढूंढता है, और NOT किसी विशेष शब्द को बाहर करता है।'
},
{
question: '\'Truncation\' शब्द निम्नलिखित में से किससे जुड़ा हुआ है:',
options: ['Classification', 'Indexing', 'Cataloguing', 'SearchTechnique'],
answer: 3,
explanation: '\'Truncation\' शब्द Search Technique (खोज तकनीक) से जुड़ा हुआ है। यह एक खोज रणनीति है जिसमें किसी शब्द के तने (stem) का उपयोग करके उस शब्द के विभिन्न रूपों (जैसे एकवचन, बहुवचन) को खोजने के लिए किया जाता है, आमतौर पर ट्रंकेशन प्रतीक (* या ?) का उपयोग करके।'
},
{
question: '\'Truncation\' शब्द का अर्थ है:',
options: ['डेटाबेस में प्रासंगिक रिकॉर्ड की कुल संख्या के लिए पुनर्प्राप्त प्रासंगिक रिकॉर्ड की संख्या का अनुपात', 'एक खोज तकनीक है जिसका उपयोग डेटाबेस में किया जाता है जिसमें एक शब्द के अंत को एक प्रतीक (symbol) द्वारा बदल दिया जाता है', 'डेटाबेस में रिकॉर्ड की कुल संख्या', 'डेटाबेस में अप्रासंगिक रिकॉर्ड की कुल संख्या'],
answer: 1,
explanation: '\'Truncation\' एक खोज तकनीक है जिसका उपयोग डेटाबेस में किया जाता है जिसमें एक शब्द के अंत को एक प्रतीक (जैसे * या ?) द्वारा बदल दिया जाता है ताकि उस शब्द के विभिन्न रूपों (जैसे लाइब्रेरी*, लाइब्रेरियन, लाइब्रेरीज) को खोजा जा सके।'
},
{
question: 'डेटाबेस में प्रासंगिक रिकॉर्ड की कुल संख्या के लिए पुनर्प्राप्त प्रासंगिक रिकॉर्ड की संख्या का अनुपात कहलाता है:',
options: ['Recall', 'Precision', 'Satatistics', 'इनमें से कोई नहीं'],
answer: 0,
explanation: 'डेटाबेस में प्रासंगिक रिकॉर्ड की कुल संख्या के लिए पुनर्प्राप्त प्रासंगिक रिकॉर्ड की संख्या का अनुपात Recall (रिकॉल) कहलाता है। यह सूचना पुनर्प्राप्ति प्रणाली की दक्षता का माप है कि वह कितने प्रासंगिक दस्तावेज ढूंढ पाती है।'
},
{
question: 'डेटाबेस में पुनर्प्राप्त किए गए प्रासंगिक रिकॉर्ड की संख्या और पुनर्प्राप्त किए गए अप्रासंगिक और प्रासंगिक रिकॉर्ड की कुल संख्या का अनुपात कहलाता है:',
options: ['Recall', 'Precision', 'Satatistics', 'इनमें से कोई नहीं'],
answer: 1,
explanation: 'डेटाबेस में पुनर्प्राप्त किए गए प्रासंगिक रिकॉर्ड की संख्या और पुनर्प्राप्त किए गए अप्रासंगिक और प्रासंगिक रिकॉर्ड की कुल संख्या का अनुपात Precision (प्रेसिजन) कहलाता है। यह सूचना पुनर्प्राप्ति प्रणाली की सटीकता का माप है कि पुनर्प्राप्त परिणामों में कितने सही हैं।'
},
{
question: '\'सूचना पुनर्प्राप्ति\' शब्द केल्विन मूर्स द्वारा किस वर्ष गढ़ा गया था :',
options: ['1950 में', '1960 में', '1970 में', '1980 में'],
answer: 0,
explanation: '\'सूचना पुनर्प्राप्ति\' (Information Retrieval) शब्द केल्विन मूर्स (Calvin Mooers) द्वारा 1950 में गढ़ा गया था। यह सूचना विज्ञान और कंप्यूटर विज्ञान का एक क्षेत्र है जो बड़े संग्रह से जानकारी खोजने से संबंधित है।'
},
{
question: '\'IRS\' शब्द का पूर्ण रूप होता है :',
options: ['Internet Retrieval System', 'Information Retrieval Space', 'Information Retrieval Source', 'Information Retrieval System'],
answer: 3,
explanation: '\'IRS\' शब्द का पूर्ण रूप Information Retrieval System (सूचना पुनर्प्राप्ति प्रणाली) होता है। यह एक प्रणाली है जो उपयोगकर्ताओं को डेटाबेस या संग्रह से संबंधित जानकारी खोजने में मदद करती है।'
},
{
question: '\'Information Retrieval को इस प्रकार किसने परिभाषित किया है Searching and retrieval of information from storage according to specification by subject."',
options: ['Calvin Moors', 'J. H. Shera', 'Ranganathan', 'Davis and Draege'],
answer: 0,
explanation: 'यह परिभाषा "Information Retrieval को इस प्रकार किसने परिभाषित किया है Searching and retrieval of information from storage according to specification by subject" Calvin Mooers द्वारा दी गई है। उन्होंने सूचना पुनर्प्राप्ति के क्षेत्र में महत्वपूर्ण योगदान दिया।'
},
{
question: 'एलसीएसएच (LCSH) का क्या मतलब है?',
options: ['लाइब्रेरी ऑफ कांग्रेस स्टैंडर्ड हेडिंग्स', 'लाइब्रेरी ऑफ कांग्रेस सब्जेक्ट हेडिंग्स', 'लाइब्रेरी ऑफ कैटलॉगिंग सब्जेक्ट हेडिंग्स', 'लाइब्रेरी ऑफ साइटेशन सब्जेक्ट हेडिंग्स'],
answer: 1,
explanation: 'एलसीएसएच (LCSH) का मतलब लाइब्रेरी ऑफ कांग्रेस सब्जेक्ट हेडिंग्स (Library of Congress Subject Headings) है। यह अंग्रेजी भाषा में सबसे व्यापक रूप से उपयोग की जाने वाली विषय शीर्षक सूची में से एक है।'
},
{
question: 'LCSH का मुख्य रूप से उपयोग किया जाता है:',
options: ['पुस्तकों को सूचीबद्ध करना', 'पत्रिकाओं को अनुक्रमित करना', 'पुस्तकालय संग्रह को व्यवस्थित करना', 'उपरोक्त सभी'],
answer: 3,
explanation: 'LCSH (Library of Congress Subject Headings) का उपयोग मुख्य रूप से पुस्तकालय संग्रह को व्यवस्थित करने के लिए विषय पहुँच प्रदान करने हेतु किया जाता है। इसका उपयोग पुस्तकों, पत्रिकाओं और अन्य सामग्रियों को सूचीबद्ध करने और अनुक्रमित करने में होता है।'
},
{
question: 'निम्नलिखित में से कौन LCSH की विशेषता है?',
options: ['यह पदानुक्रमित है', 'इसका उपयोग केवल यू.एस. में किया जाता है', 'इसमें केवल साहित्य से संबंधित शब्द शामिल हैं', 'इसे नियमित रूप से अपडेट नहीं किया जाता है'],
answer: 0,
explanation: 'LCSH (Library of Congress Subject Headings) की एक प्रमुख विशेषता इसका पदानुक्रमित (hierarchical) होना है। इसमें व्यापक और संकीर्ण शब्दों के बीच संबंध दर्शाए जाते हैं।'
},
{
question: 'विषय शीर्षकों का प्राथमिक उद्देश्य क्या है?',
options: ['लेखक की जानकारी प्रदान करना', 'विषय के आधार पर सामग्री को वर्गीकृत करना', 'प्रकाशन तिथियों को सूचीबद्ध करना', 'प्रकाशन की भाषा की पहचान करना'],
answer: 1,
explanation: 'विषय शीर्षकों (Subject Headings) का प्राथमिक उद्देश्य विषय के आधार पर सामग्री को वर्गीकृत करना और व्यवस्थित करना है ताकि उपयोगकर्ता किसी विशेष विषय पर संबंधित जानकारी आसानी से खोज सकें।'
},
{
question: 'इनमें से कौन LCSH में विषय शीर्षक का एक उदाहरण है?',
options: ['"फ़िक्शन"', '"अमेरिकी साहित्य"', '"लाइब्रेरी साइंस"', 'उपरोक्त सभी'],
answer: 3,
explanation: 'LCSH (Library of Congress Subject Headings) में "फ़िक्शन", "अमेरिकी साहित्य", और "लाइब्रेरी साइंस" सभी विषय शीर्षकों के उदाहरण हैं। LCSH विभिन्न विषयों और रूपों को कवर करता है।'
},
{
question: 'LCSH में उपविभाजनों का क्या कार्य है?',
options: ['समानार्थी शब्द बनाना', 'किसी विषय के पहलुओं को निर्दिष्ट करना', 'पुराने शब्दों को बदलना', 'भाषा की पहचान करना'],
answer: 1,
explanation: 'LCSH (Library of Congress Subject Headings) में उपविभाजनों (subdivisions) का कार्य किसी विषय के विशिष्ट पहलुओं (aspects) को निर्दिष्ट करना है। यह मुख्य विषय शीर्षक को और अधिक विशिष्ट बनाने में मदद करता है (जैसे, "शिक्षा--इतिहास")।'
},
{
question: 'LCSH को कितनी बार अपडेट किया जाता है?',
options: ['हर महीने', 'साल में दो बार', 'सालाना', 'आवश्यकतानुसार'],
answer: 3,
explanation: 'LCSH (Library of Congress Subject Headings) को आवश्यकतानुसार (as needed) अपडेट किया जाता है। लाइब्रेरी ऑफ कांग्रेस लगातार नए विषयों और अवधारणाओं को शामिल करने के लिए इसमें संशोधन करती रहती है।'
},
{
question: 'LCSH का रखरखाव किस संगठन द्वारा किया जाता है?',
options: ['अमेरिकन लाइब्रेरी एसोसिएशन', 'लाइब्रेरी ऑफ कांग्रेस', 'राष्ट्रीय अभिलेखागार', 'इंटरनेशनल फेडरेशन ऑफ लाइब्रेरी एसोसिएशन'],
answer: 1,
explanation: 'LCSH (Library of Congress Subject Headings) का रखरखाव लाइब्रेरी ऑफ कांग्रेस (Library of Congress) द्वारा किया जाता है। वे इसे अद्यतित रखने और विकसित करने के लिए जिम्मेदार हैं।'
},
{
question: '"नियंत्रित शब्दावली" क्या है?',
options: ['यादृच्छिक शब्दों की सूची', 'अनुक्रमण के लिए मानकीकृत शब्दों का एक सेट', 'समानार्थी शब्दों का शब्दकोश', 'विषयों की एक अनौपचारिक सूची'],
answer: 1,
explanation: '"नियंत्रित शब्दावली" (Controlled Vocabulary) अनुक्रमण और पुनर्प्राप्ति के लिए मानकीकृत शब्दों का एक सेट है। यह सुनिश्चित करता है कि एक ही अवधारणा को हमेशा एक ही शब्द या वाक्यांश द्वारा दर्शाया जाए, जिससे खोज अधिक सटीक होती है।'
},
{
question: 'SLSH का क्या अर्थ है?',
options: ['सियर्स लिस्ट ऑफ सब्जेक्ट हेडिंग्स', 'सब्जेक्ट हेडिंग्स की मानक सूची', 'सब्जेक्ट हेडिंग्स की व्यवस्थित सूची', 'सब्जेक्ट हेडिंग्स की सरलीकृत सूची'],
answer: 0,
explanation: 'SLSH का अर्थ सियर्स लिस्ट ऑफ सब्जेक्ट हेडिंग्स (Sears List of Subject Headings) है। यह छोटे और माध्यम आकार के पुस्तकालयों के लिए डिज़ाइन की गई एक विषय शीर्षक सूची है।'
},
{
question: 'SLSH का मुख्य रूप से उपयोग किया जाता है:',
options: ['अकादमिक पुस्तकालय', 'सार्वजनिक पुस्तकालय', 'विशेष पुस्तकालय', 'सभी प्रकार के पुस्तकालय'],
answer: 3,
explanation: 'SLSH (Sears List of Subject Headings) का उपयोग मुख्य रूप से छोटे और मध्यम आकार के सार्वजनिक पुस्तकालयों, स्कूल पुस्तकालयों और कभी-कभी छोटे अकादमिक पुस्तकालयों सहित सभी प्रकार के पुस्तकालयों द्वारा किया जाता है। यह LCSH की तुलना में एक सरल शब्दावली प्रदान करता है।'
},
{
question: 'निम्नलिखित में से कौन SLSH का सबसे अच्छा वर्णन करता है?',
options: ['LCSH से अधिक व्यापक', 'LCSH की तुलना में सरल और उपयोग में आसान', 'केवल चिकित्सा विषयों के लिए उपयोग किया जाता है', 'अब उपयोग में नहीं'],
answer: 1,
explanation: 'SLSH (Sears List of Subject Headings) का सबसे अच्छा वर्णन यह है कि यह LCSH की तुलना में सरल और उपयोग में आसान है। इसमें कम शीर्षक और सरल संरचना होती है, जो इसे छोटे संग्रह वाले पुस्तकालयों के लिए अधिक उपयुक्त बनाती है।'
},
{
question: 'इनमें से कौन SLSH की विशेषता है?',
options: ['यह जटिल शब्दावली का उपयोग करता है', 'यह छोटे और माध्यम आकार के पुस्तकालयों के लिए आदर्श है', 'यह केवल प्रिंट में उपलब्ध है', 'यह विशेष रूप से बच्चों के साहित्य के लिए है'],
answer: 1,
explanation: 'SLSH (Sears List of Subject Headings) की एक विशेषता यह है कि यह छोटे और माध्यम आकार के पुस्तकालयों के लिए आदर्श है। इसकी सरलता और सीमित आकार इन पुस्तकालयों की आवश्यकताओं को पूरा करता है।'
},
{
question: 'LCSH की तुलना में SLSH का एक अनूखा पहलू क्या है?',
options: ['अधिक विशिष्ट शब्द', 'लोकप्रिय सामग्रियों पर ध्यान केंद्रित करना', 'दुर्लभ विषयों पर अधिक जोर', 'कई भाषाओं का उपयोग'],
answer: 1,
explanation: 'LCSH की तुलना में SLSH का एक अनूखा पहलू लोकप्रिय सामग्रियों पर ध्यान केंद्रित करना है। यह उन विषयों और शब्दावली को प्राथमिकता देता है जो छोटे और सार्वजनिक पुस्तकालयों के संग्रह में अधिक सामान्य हैं।'
},
{
question: 'SLSH उपविभाजनों को कैसे संभालता है?',
options: ['यह उपविभाजनों का उपयोग नहीं करता है', 'यह उपविभाजनों की एक जटिल प्रणाली का उपयोग करता है', 'उपविभाजन सीमित हैं', 'यह केवल कल्पना के लिए उपविभाजनों का उपयोग करता है'],
answer: 2,
explanation: 'SLSH (Sears List of Subject Headings) में उपविभाजन (subdivisions) सीमित हैं। यह LCSH की तरह उपविभाजनों की एक जटिल प्रणाली का उपयोग नहीं करता है, बल्कि केवल सबसे सामान्य और आवश्यक उपविभाजनों को शामिल करता है।'
},
{
question: 'कौन सा संगठन SLSH प्रकाशित करता है?',
options: ['अमेरिकन लाइब्रेरी एसोसिएशन', 'H.W. विल्सन कंपनी', 'लाइब्रेरी ऑफ़ कांग्रेस', 'इंटरनेशनल फेडरेशन ऑफ़ लाइब्रेरी एसोसिएशन'],
answer: 1,
explanation: 'SLSH (Sears List of Subject Headings) को H.W. विल्सन कंपनी (H.W. Wilson Company) प्रकाशित करती है। यह पुस्तकालय और सूचना विज्ञान से संबंधित प्रकाशनों के लिए जानी जाती है।'
},
{
question: 'MeSH का क्या अर्थ है?',
options: ['चिकित्सा विषय शीर्षक (Medical Subject Hedings)', 'चिकित्सा मानक शीर्षक', 'चिकित्सा सरलीकृत शीर्षक', 'चिकित्सा व्यवस्थित शीर्षक'],
answer: 0,
explanation: 'MeSH का अर्थ चिकित्सा विषय शीर्षक (Medical Subject Headings) है। यह चिकित्सा और स्वास्थ्य विज्ञान के क्षेत्र के लिए एक व्यापक नियंत्रित शब्दावली है।'
},
{
question: 'MeSH का मुख्य रूप से उपयोग किया जाता है:',
options: ['चिकित्सा साहित्य को सूचीबद्ध करना', 'पुस्तकालय संग्रह को व्यवस्थित करना', 'सम्मेलन पत्रों को अनुक्रमित करना', 'उपरोक्त सभी'],
answer: 3,
explanation: 'MeSH (Medical Subject Headings) का उपयोग मुख्य रूप से चिकित्सा साहित्य (जैसे जर्नल लेख, पुस्तकें) को सूचीबद्ध करने और अनुक्रमित करने के लिए किया जाता है। यह चिकित्सा पुस्तकालयों और डेटाबेस में जानकारी खोजने के लिए एक महत्वपूर्ण उपकरण है।'
},
{
question: 'निम्नलिखित में से कौन MeSH की विशेषता है?',
options: ['गैर-चिकित्सा विषयों पर ध्यान केंद्रित करना', 'पदानुक्रमित संरचना', 'केवल नैदानिक शब्द शामिल हैं', 'केवल यू.एस. में उपयोग किया जाता है'],
answer: 1,
explanation: 'MeSH (Medical Subject Headings) की एक प्रमुख विशेषता इसकी पदानुक्रमित (hierarchical) संरचना है। इसमें चिकित्सा अवधारणाओं को व्यापक से विशिष्ट तक व्यवस्थित किया जाता है।'
},
{
question: 'MeSH का प्राथमिक उद्देश्य क्या है?',
options: ['नैदानिक दिशानिर्देश बनाना', 'चिकित्सा शब्दावली को मानकीकृत करना', 'रोगी शिक्षा प्रदान करना', 'चिकित्सा अनुसंधान को बढ़ावा देना'],
answer: 1,
explanation: 'MeSH (Medical Subject Headings) का प्राथमिक उद्देश्य चिकित्सा शब्दावली को मानकीकृत करना है। यह चिकित्सा साहित्य के अनुक्रमण और खोज के लिए एक सुसंगत और नियंत्रित शब्दावली प्रदान करता है।'
},
{
question: 'MeSH का रखरखाव किस संगठन द्वारा किया जाता है?',
options: ['विश्व स्वास्थ्य संगठन', 'राष्ट्रीय चिकित्सा पुस्तकालय (USA)', 'अमेरिकन मेडिकल एसोसिएशन', 'लाइब्रेरी ऑफ काँग्रेस'],
answer: 1,
explanation: 'MeSH (Medical Subject Headings) का रखरखाव राष्ट्रीय चिकित्सा पुस्तकालय (National Library of Medicine - NLM), USA द्वारा किया जाता है। NLM चिकित्सा सूचना संसाधनों का दुनिया का सबसे बड़ा पुस्तकालय है।'
},
{
question: 'MeSH द्वारा किस पहलू को कवर नहीं किया जाता है?',
options: ['रोग', 'चिकित्सा प्रक्रियाएँ', 'काल्पनिक साहित्य', 'औषध विज्ञान'],
answer: 2,
explanation: 'MeSH (Medical Subject Headings) मुख्य रूप से चिकित्सा और स्वास्थ्य विज्ञान से संबंधित विषयों को कवर करता है। यह रोग, चिकित्सा प्रक्रियाएँ और औषध विज्ञान जैसे पहलुओं को शामिल करता है, लेकिन काल्पनिक साहित्य (Fiction) को कवर नहीं करता है।'
},
{
question: 'MeSH को कितनी बार अपडेट किया जाता है?',
options: ['मासिक', 'सालाना', 'अर्धवार्षिक', 'आवश्यकतानुसार'],
answer: 1,
explanation: 'MeSH (Medical Subject Headings) को सालाना (annually) अपडेट किया जाता है। हर साल नए शब्दों और अवधारणाओं को जोड़ा जाता है और मौजूदा शब्दों में संशोधन किया जाता है।'
},
{
question: 'MeSH में "वर्णनकर्ता" क्या है?',
options: ['शब्द का पर्यायवाची', 'लेखों को अनुक्रमित करने के लिए उपयोग किया जाने वाला शब्द', 'एक सामान्य श्रेणी', 'एक संबंधित अवधारणा'],
answer: 1,
explanation: 'MeSH में "वर्णनकर्ता" (Descriptor) लेखों या अन्य साहित्य को अनुक्रमित करने के लिए उपयोग किया जाने वाला मुख्य शब्द या वाक्यांश है। यह चिकित्सा अवधारणाओं का प्रतिनिधित्व करता है।'
},
{
question: 'MeSH में "क्वालिफायर" क्या दर्शाते हैं?',
options: ['किसी विषय के विशिष्ट पहलू', 'यादृच्छिक संघ', 'पुराने शब्द', 'गैर-चिकित्सा विषय'],
answer: 0,
explanation: 'MeSH में "क्वालिफायर" (Qualifiers) किसी विषय के विशिष्ट पहलू (specific aspects) को दर्शाते हैं। इन्हें मुख्य वर्णनकर्ता के साथ जोड़ा जाता है ताकि विषय को और अधिक विशिष्ट बनाया जा सके (जैसे, "मधुमेह/आहार चिकित्सा")।'
},
{
question: 'विषय शीर्षकों का उपयोग करने का निम्नलिखित में से कौन सा लाभ है?',
options: ['बेहतर खोज सटीकता', 'बढ़ी हुई उलझन', 'सूचीकरण में अतिरेक', 'सामग्री तक सीमित पहुंच'],
answer: 0,
explanation: 'विषय शीर्षकों का उपयोग करने का एक प्रमुख लाभ बेहतर खोज सटीकता (better search accuracy) है। नियंत्रित शब्दावली का उपयोग करके, उपयोगकर्ता अपनी खोज को संकीर्ण कर सकते हैं और अधिक प्रासंगिक परिणाम प्राप्त कर सकते हैं।'
},
{
question: 'एलसीएसएच और मेश (MeSH) के बीच मुख्य अंतर क्या है?',
options: ['एलसीएसएच का दायरा व्यापक है', 'मेश केवल चिकित्सा विषयों तक ही सीमित है', 'एलसीएसएच में अधिक तकनीकी शब्द शामिल हैं', 'मेश पदानुक्रमित नहीं है'],
answer: 1,
explanation: 'एलसीएसएच (LCSH) और मेश (MeSH) के बीच मुख्य अंतर यह है कि मेश केवल चिकित्सा और स्वास्थ्य विज्ञान विषयों तक ही सीमित है, जबकि एलसीएसएच का दायरा बहुत व्यापक है और इसमें सभी विषयों को शामिल किया जाता है।'
},
{
question: 'एलसीएसएच (LCSH) की तुलना में एसएलएसएच (SLSH) के बारे में निम्नलिखित में से कौन सा सत्य है?',
options: ['एसएलएसएच अधिक व्यापक है', 'एसएलएसएच सरल और अधिक सुलभ है', 'एसएलएसएच का उपयोग केवल शैक्षणिक पुस्तकालयों में किया जाता है', 'एसएलएसएच सामग्री को वर्गीकृत नहीं करता है'],
answer: 1,
explanation: 'एलसीएसएच (LCSH) की तुलना में एसएलएसएच (SLSH) सरल और अधिक सुलभ है। इसमें कम शीर्षक और सरल संरचना होती है, जो इसे छोटे और मध्यम आकार के पुस्तकालयों के लिए अधिक उपयुक्त बनाती है।'
},
{
question: 'किस प्रकार के पुस्तकालय मुख्य रूप से MeSH का उपयोग करते हैं?',
options: ['सार्वजनिक पुस्तकालय', 'शैक्षणिक पुस्तकालय', 'चिकित्सा पुस्तकालय', 'सभी पुस्तकालय'],
answer: 2,
explanation: 'मुख्य रूप से चिकित्सा पुस्तकालय (Medical Libraries) MeSH (Medical Subject Headings) का उपयोग करते हैं। यह चिकित्सा और स्वास्थ्य विज्ञान साहित्य के अनुक्रमण और खोज के लिए एक मानक उपकरण है।'
},
{
question: 'एक छोटे सार्वजनिक पुस्तकालय के लिए कौन सी विषय शीर्षक प्रणाली सर्वोत्तम होगी?',
options: ['LCSH', 'SLSH', 'MeSH', 'उपरोक्त में से कोई नहीं'],
answer: 1,
explanation: 'एक छोटे सार्वजनिक पुस्तकालय के लिए SLSH (Sears List of Subject Headings) सर्वोत्तम होगी। यह LCSH की तुलना में सरल और कम व्यापक है, जो इसे छोटे संग्रह और कम कर्मचारियों वाले पुस्तकालयों के लिए अधिक प्रबंधनीय बनाती है। MeSH चिकित्सा साहित्य के लिए है और LCSH बड़े पुस्तकालयों के लिए अधिक उपयुक्त है।'
},
{
question: 'चिकित्सा अनुसंधान अनुक्रमण के लिए मुख्य रूप से किस उपकरण का उपयोग किया जाता है?',
options: ['SLSH', 'LCSH', 'MeSH', 'उपरोक्त सभी'],
answer: 2,
explanation: 'चिकित्सा अनुसंधान अनुक्रमण (indexing medical research) के लिए मुख्य रूप से MeSH (Medical Subject Headings) उपकरण का उपयोग किया जाता है। यह चिकित्सा साहित्य डेटाबेस जैसे PubMed में अनुक्रमण के लिए मानक शब्दावली है।'
},
{
question: 'कौन सी विषय शीर्षक प्रणाली एक पदानुक्रमित संरचना का उपयोग करती है?',
options: ['केवल SLSH', 'केवल LCSH', 'केवल MeSH', 'उपरोक्त सभी'],
answer: 3,
explanation: 'LCSH (Library of Congress Subject Headings) और MeSH (Medical Subject Headings) दोनों ही पदानुक्रमित संरचना का उपयोग करते हैं। SLSH भी कुछ हद तक पदानुक्रमित संबंध दिखाता है। इसलिए, उपरोक्त सभी विकल्प इस संदर्भ में सही माने जा सकते हैं कि ये प्रणालियाँ पदानुक्रमित संबंध दर्शाती हैं।'
},
{
question: 'LCSH में निम्नलिखित में से कौन सा उपविभाजन मान्य है?',
options: ['"इतिहास"', '"अध्ययन और शिक्षण"', '"स्वास्थ्य पहलू"', 'उपरोक्त सभी'],
answer: 3,
explanation: 'LCSH (Library of Congress Subject Headings) में "इतिहास", "अध्ययन और शिक्षण", और "स्वास्थ्य पहलू" सभी मान्य उपविभाजन हैं। इन उपविभाजनों का उपयोग मुख्य विषय शीर्षक को अधिक विशिष्ट बनाने के लिए किया जाता है।'
},
{
question: 'MeSH में, "प्रविष्टि शब्द" शब्द का क्या अर्थ है?',
options: ['वर्णनकर्ता के लिए समानार्थी शब्द', 'अप्रचलित शब्द', 'अनुक्रमण में उपयोग न किए जाने वाले शब्द', 'गैर-चिकित्सा शब्द'],
answer: 0,
explanation: 'MeSH (Medical Subject Headings) में, "प्रविष्टि शब्द" (Entry Term) वर्णनकर्ता (Descriptor) के लिए समानार्थी शब्द (synonym) या लगभग समानार्थी शब्द है। ये वे शब्द होते हैं जिनका उपयोग उपयोगकर्ता खोजते समय कर सकते हैं, और वे उन्हें संबंधित वर्णनकर्ता तक निर्देशित करते हैं।'
},
{
question: 'पुस्तकालय विज्ञान में नियंत्रित शब्दावली क्यों महत्वपूर्ण है?',
options: ['यह भ्रम पैदा करता है', 'यह स्थिरता के लिए शब्दों को मानकीकृत करता है', 'यह खोज क्षमताओं को सीमित करता है', 'यह छोटे पुस्तकालयों के लिए अनावश्यक है'],
answer: 1,
explanation: 'पुस्तकालय विज्ञान में नियंत्रित शब्दावली (Controlled Vocabulary) इसलिए महत्वपूर्ण है क्योंकि यह स्थिरता के लिए शब्दों को मानकीकृत करता है। यह सुनिश्चित करता है कि एक ही अवधारणा को हमेशा एक ही तरीके से अनुक्रमित किया जाए, जिससे उपयोगकर्ताओं के लिए जानकारी खोजना आसान हो जाता है।'
},
{
question: 'मधुमेह पर शोध पत्र के लिए कौन सी विषय शीर्षक प्रणाली सबसे उपयुक्त होगी?',
options: ['SLSH', 'LCSH', 'MeSH', 'उपरोक्त में से कोई नहीं'],
answer: 2,
explanation: 'मधुमेह (Diabetes) पर शोध पत्र जैसे चिकित्सा विषय के लिए MeSH (Medical Subject Headings) विषय शीर्षक प्रणाली सबसे उपयुक्त होगी। MeSH चिकित्सा और स्वास्थ्य विज्ञान के क्षेत्र में विशेषज्ञता प्रदान करता है।'
},
{
question: 'एकाधिक विषय शीर्षक प्रणाली होने का क्या लाभ है?',
options: ['बढ़ी हुई जटिलता', 'विभिन्न विषयों के लिए विशेष ध्यान', 'अनुक्रमण में अतिरेक', 'सूचना तक सीमित पहुँच'],
answer: 1,
explanation: 'एकाधिक विषय शीर्षक प्रणाली होने का लाभ यह है कि यह विभिन्न विषयों और आवश्यकताओं के लिए विशेष ध्यान (specialized focus) प्रदान करता है। विभिन्न प्रणालियाँ विशिष्ट क्षेत्रों या पुस्तकालयों के प्रकारों के लिए बेहतर अनुकूल हो सकती हैं।'
},
{
question: 'निम्नलिखित में से कौन सा समूह मुख्य रूप से MeSH से लाभान्वित होता है?',
options: ['आम जनता', 'चिकित्सा शोधकर्ता और पेशेवर', 'कथा लेखक', 'सार्वजनिक पुस्तकालयों में लाइब्रेरियन'],
answer: 1,
explanation: 'मुख्य रूप से चिकित्सा शोधकर्ता और पेशेवर MeSH (Medical Subject Headings) से लाभान्वित होते हैं। MeSH चिकित्सा साहित्य डेटाबेस में जानकारी खोजने के लिए एक आवश्यक उपकरण है।'
},
{
question: 'विषय शीर्षकों में "संबंधित शब्दों" का क्या महत्व है?',
options: ['वे समानार्थी शब्द प्रदान करते हैं', 'वे समान अवधारणाओं को जोड़ते हैं', 'वे उपयोगकर्ताओं को भ्रमित करते हैं', 'वे पुराने हो चुके हैं'],
answer: 1,
explanation: 'विषय शीर्षकों में "संबंधित शब्दों" (Related Terms - RT) का महत्व यह है कि वे समान अवधारणाओं (similar concepts) को जोड़ते हैं। यह उपयोगकर्ताओं को उनकी खोज को व्यापक बनाने या संबंधित विषयों का पता लगाने में मदद करता है।'
},
{
question: 'विषय शीर्षक प्रणाली का चयन करते समय एक महत्वपूर्ण विचार क्या है?',
options: ['भौतिक प्रतियों की उपलब्धता', 'पुस्तकालय के उपयोगकर्ताओं की विशिष्ट ज़रूरतें', 'प्रणाली की लोकप्रियता', 'शर्तों की लंबाई'],
answer: 1,
explanation: 'विषय शीर्षक प्रणाली का चयन करते समय एक महत्वपूर्ण विचार पुस्तकालय के उपयोगकर्ताओं की विशिष्ट ज़रूरतें (specific needs of the library\'s users) हैं। पुस्तकालय को ऐसी प्रणाली का चयन करना चाहिए जो उसके उपयोगकर्ताओं द्वारा खोजी जाने वाली सामग्री के विषयों और गहराई को प्रभावी ढंग से कवर करती हो।'
}
    ];

    let questions = [];
    let current = 0;
    let score = 0;
    let answers = JSON.parse(localStorage.getItem("quizAnswers")) || {};
    let currentFontSize = parseFloat(localStorage.getItem("quizFontSize")) || 20;
    let shuffledQuestionsOrder = JSON.parse(localStorage.getItem("shuffledQuestionsOrder")) || null;
    let shuffledOptionsOrder = JSON.parse(localStorage.getItem("shuffledOptionsOrder")) || {};
    let questionTimes = JSON.parse(localStorage.getItem("questionTimes")) || {};
    let currentQuestionStartTime = null;
    let timerInterval = null;

    if (shuffledQuestionsOrder) {
      questions = shuffledQuestionsOrder.map(index => originalQuestions[index]);
    } else {
      questions = [...originalQuestions];
    }

    function toggleSidebar() {
      const sidebar = document.getElementById("sidebar");
      const body = document.body;
      sidebar.classList.toggle("hidden");
      body.classList.toggle("sidebar-visible");
      if (sidebar.classList.contains("hidden")) {
        body.style.paddingLeft = "20px";
      } else {
        body.style.paddingLeft = body.clientWidth > 768 ? "240px" : "220px";
      }
    }

    function startTimer() {
      if (timerInterval) clearInterval(timerInterval);
      currentQuestionStartTime = Date.now();
      timerInterval = setInterval(() => {
        const elapsed = Math.floor((Date.now() - currentQuestionStartTime) / 1000);
        document.getElementById("time-tracking").innerText = `समय: ${elapsed} सेकंड`;
      }, 1000);
    }

    function stopTimer() {
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
      const elapsed = Math.floor((Date.now() - currentQuestionStartTime) / 1000);
      questionTimes[current] = (questionTimes[current] || 0) + elapsed;
      localStorage.setItem("questionTimes", JSON.stringify(questionTimes));
      document.getElementById("time-tracking").innerText = `समय: ${elapsed} सेकंड`;
    }

function loadQuestion(index) {
  if (index >= 0 && index < questions.length) {
    if (currentQuestionStartTime !== null) {
      stopTimer();
    }
    current = index;
    localStorage.setItem("currentQuestion", current);
    const currentQuestionInOriginalOrder = originalQuestions.find(q => q.question === questions[current].question);
    const q = questions[current];
    let html = `<div class='question' id='current-question-text'>Q${current + 1}. ${q.question}</div>`;
    
    const questionLists = {
      // Example: Add list for specific questions if needed in future
      285: `<ul class="two-column-list">
<li>(i)लेखक विवरण,</li>
<li>(ii)आख्या एवं उत्तरदायित्व विवरण,</li>  
<li>(iii)प्रकाशन वर्ष,</li> 
<li>(iv)पृष्ट संख्या</li>
</ul>`
    };
    if (questionLists[index]) { // Index here refers to the current shuffled index
        // If you need to map this to original question index for lists, adjust logic
      html += questionLists[index];
    }

    let optionsToDisplay = [...q.options];
    let currentOptionsOrder = shuffledOptionsOrder[current]; // Use 'current' which is the index in 'questions' array
    if (!currentOptionsOrder) {
      currentOptionsOrder = Array.from({length: optionsToDisplay.length}, (_, i) => i);
    } else {
      let reorderedOptions = [];
      currentOptionsOrder.forEach(optionIndex => {
        reorderedOptions.push(q.options[optionIndex]); // q.options should be correct here
      });
      optionsToDisplay = reorderedOptions;
    }

    optionsToDisplay.forEach((opt, i) => {
      const originalOptionIndex = q.options.indexOf(opt); // This finds the original index of the option from the potentially shuffled q.options
      const selected = answers[current] == originalOptionIndex ? "checked" : ""; // answers are stored with original option index
      const disabled = answers[current] !== undefined ? "disabled" : "";
      const lockedClass = answers[current] !== undefined && answers[current] == originalOptionIndex ? "locked" : "";
      html += `<label id='opt${i}' class='${lockedClass}'><input type='radio' name='q${current}' value='${originalOptionIndex}' ${selected} ${disabled} onclick='selectAnswer(${current}, ${originalOptionIndex})'> ${opt}</label>`;
    });

    html += `<div class='correct-answer' id='correct'></div>`;
    html += `<div class='explanation' id='explanation-text' style='display: none;'></div>`;
    document.getElementById("quiz-content").innerHTML = html;
    document.getElementById("completion-message").innerText = "";
    document.getElementById("result").innerText = "";

    if (answers[current] !== undefined) { // Check if the current question (by shuffled index) has an answer
      const selectedOriginalIndex = answers[current];
      const correctOriginalIndex = currentQuestionInOriginalOrder.answer; // currentQuestionInOriginalOrder is correctly identified
      
      // Map original indices back to displayed indices for highlighting
      const selectedDisplayedIndex = optionsToDisplay.indexOf(q.options[selectedOriginalIndex]);
      const correctDisplayedIndexIfDifferent = optionsToDisplay.indexOf(q.options[correctOriginalIndex]);


      if (selectedOriginalIndex === correctOriginalIndex) {
        if (selectedDisplayedIndex !== -1) {
          document.getElementById(`opt${selectedDisplayedIndex}`).classList.add("correct");
        }
      } else {
        if (selectedDisplayedIndex !== -1) {
          document.getElementById(`opt${selectedDisplayedIndex}`).classList.add("incorrect");
        }
        if (correctDisplayedIndexIfDifferent !== -1) { // Highlight the correct option if a wrong one was chosen
          document.getElementById(`opt${correctDisplayedIndexIfDifferent}`).classList.add("correct");
        }
      }
      document.getElementById("correct").innerHTML = `<strong>सही उत्तर:</strong> ${currentQuestionInOriginalOrder.options[correctOriginalIndex]}`;
      
      const explanationDiv = document.getElementById("explanation-text");
      if (currentQuestionInOriginalOrder.explanation) {
        explanationDiv.innerHTML = `<strong>व्याख्या:</strong> ${currentQuestionInOriginalOrder.explanation}`;
        explanationDiv.style.display = "block";
      } else {
        explanationDiv.style.display = "none";
      }
      document.querySelectorAll(`#quiz-content label`).forEach(label => label.classList.add("locked"));
    }

    applyFontSize();
    updateSidebarHighlight();
    updateScoreSummary();
    updateProgress();
    startTimer();
    document.getElementById("time-tracking").innerText = `समय: ${questionTimes[current] || 0} सेकंड`;
  }
}

function selectAnswer(qShuffledIdx, selectedOriginalOptionIdx) {
  // qShuffledIdx is the index in the 'questions' (potentially shuffled) array
  // selectedOriginalOptionIdx is the index of the selected option from the *original* options array of that question
  if (answers[qShuffledIdx] === undefined) { // Check answer for the question at its current shuffled position
    stopTimer();
    const q = questions[qShuffledIdx]; // The question object from the shuffled list
    const originalQuestion = originalQuestions.find(oq => oq.question === q.question); // Find the corresponding original question
    
    answers[qShuffledIdx] = selectedOriginalOptionIdx; // Store answer using shuffled index as key, and original option index as value
    localStorage.setItem("quizAnswers", JSON.stringify(answers));

    document.querySelectorAll(`#quiz-content label`).forEach(label => label.classList.remove("correct", "incorrect", "locked"));
    document.querySelectorAll(`input[name='q${qShuffledIdx}']`).forEach(radio => radio.disabled = true);

    // Determine displayed options again for correct highlighting
    let optionsToDisplay = [...q.options];
    let currentFileOptionsOrder = shuffledOptionsOrder[qShuffledIdx]; // Options order for the current question in file
     if (currentFileOptionsOrder) {
        let reorderedOptions = [];
        currentFileOptionsOrder.forEach(originalOptIndex => {
            reorderedOptions.push(q.options[originalOptIndex]);
        });
        optionsToDisplay = reorderedOptions;
    }


    const selectedDisplayedIndex = optionsToDisplay.indexOf(q.options[selectedOriginalOptionIdx]);
    const correctOriginalOptionIdx = originalQuestion.answer;
    const correctDisplayedIndex = optionsToDisplay.indexOf(q.options[correctOriginalOptionIdx]);


    if (selectedOriginalOptionIdx === correctOriginalOptionIdx) {
      if (selectedDisplayedIndex !== -1) {
        document.getElementById(`opt${selectedDisplayedIndex}`).classList.add("correct");
      }
    } else {
      if (selectedDisplayedIndex !== -1) {
        document.getElementById(`opt${selectedDisplayedIndex}`).classList.add("incorrect");
      }
      if (correctDisplayedIndex !== -1) {
        document.getElementById(`opt${correctDisplayedIndex}`).classList.add("correct");
      }
    }
    document.getElementById("correct").innerHTML = `<strong>सही उत्तर:</strong> ${originalQuestion.options[correctOriginalOptionIdx]}`;

    const explanationDiv = document.getElementById("explanation-text");
    if (originalQuestion.explanation) {
      explanationDiv.innerHTML = `<strong>व्याख्या:</strong> ${originalQuestion.explanation}`;
      explanationDiv.style.display = "block";
    } else {
      explanationDiv.style.display = "none";
    }

    document.querySelectorAll(`#quiz-content label`).forEach(label => label.classList.add("locked"));
    updateProgress();
    updateSidebarHighlight(); // This needs to use qShuffledIdx for 'current' and for answers
    updateScoreSummary();
  }
}
    function nextQuestion() {
      if (current < questions.length - 1) {
        loadQuestion(current + 1);
      }
    }

    function prevQuestion() {
      if (current > 0) {
        loadQuestion(current - 1);
      }
    }

    function submitQuiz() {
      score = 0;
      questions.forEach((q, i) => { // 'i' is the index in the shuffled 'questions' array
        const originalQuestion = originalQuestions.find(oq => oq.question === q.question);
        if (answers[i] !== undefined && answers[i] == originalQuestion.answer) { // answers are keyed by shuffled index
          score++;
        }
      });
      const percentage = ((score / questions.length) * 100).toFixed(2);
      document.getElementById("result").innerHTML = `आपका स्कोर: ${score}/${questions.length} (${percentage}%)`;
      const completionMessageElement = document.getElementById("completion-message");
      if (percentage == 100) {
        completionMessageElement.innerText = "बधाई हो! आपने पूरे अंक प्राप्त किए!";
        completionMessageElement.style.color = "green";
      } else if (percentage >= 75) {
        completionMessageElement.innerText = "बहुत बढ़िया! आपने अच्छा प्रदर्शन किया।";
        completionMessageElement.style.color = "#185a9d";
      } else if (percentage >= 50) {
        completionMessageElement.innerText = "अच्छा प्रयास! आपको और अभ्यास की आवश्यकता है";
        completionMessageElement.style.color = "orange";
      } else {
        completionMessageElement.innerText = "कृपया पुनः प्रयास करें और बेहतर तैयारी करें।";
        completionMessageElement.style.color = "red";
      }
    }

    function reviewQuiz() {
      let reviewHTML = `<html><head><meta charset='UTF-8'><title>Quiz Review</title>
        <style>body{font-family:'Poppins',sans-serif;padding:20px;line-height:1.6;}
        h2{color:#185a9d;} .correct{color:green;} .incorrect{color:red;}
        .question-review { margin-bottom: 20px; padding: 15px; border: 1px solid #eee; border-radius: 8px; }
        .question-review strong { display: block; margin-bottom: 5px; }
        .correct-answer-review { color: green; font-weight: bold; }
        .user-answer-review { font-weight: bold; }
        .time-spent { color: #555; margin-top: 5px; }
        .explanation-review { margin-top: 10px; padding: 8px; background-color: #f0f0f0; border-left: 3px solid #764ba2; font-size: 0.9em;}
        body.dark { background: #121212; color: #e0e0e0; }
        body.dark h2 { color: #fff; }
        body.dark .question-review { border-color: #555; background: #333; }
        body.dark .correct-answer-review { color: #90ee90; }
        body.dark .user-answer-review { color: #ff6347; }
        body.dark .explanation-review { background-color: #2a2a2a; border-left-color: #9b70e0; color: #e0e0e0; }
        </style>
        </head><body><h2>Quiz Review</h2>`;

      questions.forEach((q, i) => { // 'i' is the index in the shuffled 'questions' array
        const userAnsOriginalOptionIdx = answers[i]; // User's answer (original option index) for the question at shuffled index 'i'
        const originalQuestion = originalQuestions.find(oq => oq.question === q.question); // Find the corresponding original question details

        reviewHTML += `<div class="question-review">`;
        reviewHTML += `<strong>Q${originalQuestions.indexOf(originalQuestion) + 1}:</strong> ${originalQuestion.question}<br>`; // Display original question number

        originalQuestion.options.forEach((opt, originalOptIdx) => {
          let className = '';
          if (originalOptIdx === originalQuestion.answer) {
            className = 'correct-answer-review';
            reviewHTML += `<span class='${className}'>${String.fromCharCode(97 + originalOptIdx)}) ${opt} (सही उत्तर)</span><br>`;
          } else if (originalOptIdx === userAnsOriginalOptionIdx) {
            className = 'user-answer-review incorrect'; // This will be incorrect if userAnsOriginalOptionIdx !== originalQuestion.answer
            reviewHTML += `<span class='${className}'>${String.fromCharCode(97 + originalOptIdx)}) ${opt} (आपका उत्तर)</span><br>`;
          } else {
            reviewHTML += `<span>${String.fromCharCode(97 + originalOptIdx)}) ${opt}</span><br>`;
          }
        });

        if (userAnsOriginalOptionIdx !== undefined && userAnsOriginalOptionIdx !== originalQuestion.answer) {
          // No need to show correct answer again here as it's highlighted above
        } else if (userAnsOriginalOptionIdx === undefined) {
          reviewHTML += `<div style="color: orange; margin-top: 5px;">आपने इस प्रश्न का उत्तर नहीं दिया था।</div>`;
        }

        if (originalQuestion.explanation) {
            reviewHTML += `<div class="explanation-review"><strong>व्याख्या:</strong> ${originalQuestion.explanation}</div>`;
        }

        reviewHTML += `<div class="time-spent">इस प्रश्न पर लिया गया समय: ${questionTimes[i] || 0} सेकंड</div>`; // Time spent on question at shuffled index 'i'
        reviewHTML += '</div>';
      });

      // The logic for retrying incorrect/unanswered questions might need adjustment
      // based on whether 'questions' or 'originalQuestions' is the primary reference.
      // For now, it's a placeholder.
      const incorrectOrUnansweredOriginalQuestions = originalQuestions.filter((oq, originalIndex) => {
        // Find if this original question was presented and how it was answered
        const presentedQuestionIndex = questions.findIndex(shuffledQ => shuffledQ.question === oq.question);
        if (presentedQuestionIndex === -1) return false; // Should not happen if all original questions are in 'questions'
        const userAnswer = answers[presentedQuestionIndex];
        return userAnswer === undefined || userAnswer !== oq.answer;
      });

      if (incorrectOrUnansweredOriginalQuestions.length > 0) {
        reviewHTML += `<button onclick='alert("गलत/अनुत्तरित प्रश्नों को पुनः प्रयास करने की सुविधा अभी विकास में है।")' style="padding: 10px 20px; background-color: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer; margin-top: 20px;">गलत/अनुत्तरित प्रश्नों का पुनः प्रयास करें</button>`;
      }
      reviewHTML += `</body></html>`;

      const newWin = window.open();
      newWin.document.write(reviewHTML);
      newWin.document.close();
    }

    function updateProgress() {
      const total = questions.length;
      let answeredCount = 0;
      // Iterate through the 'questions' array (which is currently active, possibly shuffled)
      // and check if an answer exists for each in the 'answers' object.
      // The keys in 'answers' correspond to the indices of the 'questions' array.
      for (let i = 0; i < questions.length; i++) {
        if (answers[i] !== undefined) {
          answeredCount++;
        }
      }
      document.getElementById("progress").innerText = `प्रगति: ${answeredCount}/${total} प्रश्न हल किए गए`;
    }


    function updateSidebarHighlight() {
      const allLinks = document.querySelectorAll("#questionTable a");
      allLinks.forEach((link, linkIndexOriginalOrder) => { // linkIndexOriginalOrder corresponds to the original question order in sidebar
        link.classList.remove("correct", "incorrect", "active", "unanswered");

        // Find the current shuffled index of this original question
        const originalQ = originalQuestions[linkIndexOriginalOrder];
        const currentShuffledIndexOfThisLink = questions.findIndex(q => q.question === originalQ.question);


        if (currentShuffledIndexOfThisLink === current) { // 'current' is the index in the shuffled 'questions' array
          link.classList.add("active");
        } else {
          if (answers[currentShuffledIndexOfThisLink] !== undefined) {
            link.classList.add(answers[currentShuffledIndexOfThisLink] == originalQ.answer ? "correct" : "incorrect");
          } else {
            link.classList.add("unanswered");
          }
        }
      });
    }


    function buildSidebarLinks() {
      const table = document.getElementById("questionTable");
      table.innerHTML = "";
      // Sidebar links should always correspond to the original order of questions
      // but clicking them should load the question from its current position in the (possibly shuffled) 'questions' array.
      for (let i = 0; i < originalQuestions.length; i += 5) { // Iterate based on originalQuestions length
        const row = document.createElement("tr");
        for (let j = i; j < i + 5 && j < originalQuestions.length; j++) { // j is the original index
          const cell = document.createElement("td");
          const a = document.createElement("a");
          a.href = "#";
          a.setAttribute('data-tooltip', originalQuestions[j].question.slice(0, 30) + '...');
          a.textContent = `${j + 1}`; // Display 1-based original index
          a.onclick = (function(originalQuestionIndex) {
            return function() {
              // Find where this original question is currently located in the 'questions' array
              const targetQuestionText = originalQuestions[originalQuestionIndex].question;
              const targetShuffledIndex = questions.findIndex(q => q.question === targetQuestionText);
              if (targetShuffledIndex !== -1) {
                loadQuestion(targetShuffledIndex);
              }
              return false;
            };
          })(j); // Pass original index 'j'
          cell.appendChild(a);
          row.appendChild(cell);
        }
        table.appendChild(row);
      }
    }

    function clearSavedData() {
      const confirmation = confirm("क्या आप वाकई सहेजे गए डेटा को क्लियर करना चाहते हैं? यह आपके सभी प्रगति को हटा देगा।");
      if (confirmation) {
        localStorage.removeItem("quizAnswers");
        localStorage.removeItem("currentQuestion");
        localStorage.removeItem("shuffledQuestionsOrder");
        localStorage.removeItem("shuffledOptionsOrder");
        localStorage.removeItem("questionTimes");
        localStorage.removeItem("quizFontSize");
        localStorage.removeItem("theme");
        answers = {};
        current = 0;
        shuffledQuestionsOrder = null; // This will cause 'questions' to be a copy of 'originalQuestions'
        shuffledOptionsOrder = {};
        questionTimes = {};
        currentFontSize = 20;
        // questions will be reset at the start of the script or on reload
        alert("सहेजा गया डेटा क्लियर कर दिया गया है।");
        window.location.reload(); // Reload to apply cleared state cleanly
      }
    }

    function toggleFullscreen() {
      const doc = document.documentElement;
      const fullscreenBtn = document.getElementById("fullscreen-btn");
      const icon = fullscreenBtn.querySelector("i");
      if (!document.fullscreenElement) {
        if (doc.requestFullscreen) {
          doc.requestFullscreen();
        } else if (doc.mozRequestFullScreen) {
          doc.mozRequestFullScreen();
        } else if (doc.webkitRequestFullscreen) {
          doc.webkitRequestFullscreen();
        } else if (doc.msRequestFullscreen) {
          doc.msRequestFullscreen();
        }
        // Icon and text change handled by handleFullscreenChange
      } else {
        if (document.exitFullscreen) {
          document.exitFullscreen();
        } else if (document.mozCancelFullScreen) {
          document.mozCancelFullScreen();
        } else if (document.webkitExitFullscreen) {
          document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
          document.msExitFullscreen();
        }
         // Icon and text change handled by handleFullscreenChange
      }
    }

    function toggleTheme() {
      const body = document.body;
      const themeBtn = document.getElementById("theme-btn");
      const icon = themeBtn.querySelector("i");
      body.classList.toggle("dark");
      localStorage.setItem("theme", body.classList.contains("dark") ? "dark" : "light");
      if (body.classList.contains("dark")) {
        icon.classList.remove("fa-sun");
        icon.classList.add("fa-moon");
        themeBtn.innerHTML = `<i class="fas fa-moon"></i> Light Theme`;
      } else {
        icon.classList.remove("fa-moon");
        icon.classList.add("fa-sun");
        themeBtn.innerHTML = `<i class="fas fa-sun"></i> Dark Theme`;
      }
    }

    function changeFontSize(change) {
      if (change === 0) {
        currentFontSize = 20; // Reset to default
      } else {
        currentFontSize += change;
        if (currentFontSize < 14) currentFontSize = 14; // Min font size
        if (currentFontSize > 30) currentFontSize = 30; // Max font size
      }
      localStorage.setItem("quizFontSize", currentFontSize);
      applyFontSize();
    }

    function applyFontSize() {
      const questionElement = document.getElementById("current-question-text");
      if (questionElement) {
        questionElement.style.fontSize = currentFontSize + "px";
      }
      document.querySelectorAll("#quiz-content label").forEach(label => {
        label.style.fontSize = (currentFontSize * 0.9) + "px";
      });
       const explanationElement = document.getElementById("explanation-text");
      if (explanationElement) {
        explanationElement.style.fontSize = (currentFontSize * 0.85) + "px";
      }
    }

    function setInitialIcons() {
      const themeBtn = document.getElementById("theme-btn");
      // const fullscreenBtn = document.getElementById("fullscreen-btn"); // Done in handleFullscreenChange
      const savedTheme = localStorage.getItem("theme");
      if (savedTheme === "dark") {
        document.body.classList.add("dark");
        themeBtn.innerHTML = `<i class="fas fa-moon"></i> Light Theme`;
      } else {
        themeBtn.innerHTML = `<i class="fas fa-sun"></i> Dark Theme`;
      }
      handleFullscreenChange(); // Set initial fullscreen button state
      document.addEventListener('fullscreenchange', handleFullscreenChange);
      document.addEventListener('mozfullscreenchange', handleFullscreenChange);
      document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
      document.addEventListener('msfullscreenchange', handleFullscreenChange);
    }

    function handleFullscreenChange() {
      const fullscreenBtn = document.getElementById("fullscreen-btn");
      if (document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement) {
        fullscreenBtn.innerHTML = `<i class="fas fa-compress"></i> Exit Fullscreen`;
      } else {
        fullscreenBtn.innerHTML = `<i class="fas fa-expand"></i> Toggle Fullscreen`;
      }
    }

    function shuffleArray(array) {
      const shuffled = [...array];
      for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
      }
      return shuffled;
    }

    function shuffleQuestions() {
      // Create an array of original indices
      let originalIndices = Array.from({length: originalQuestions.length}, (_, i) => i);
      shuffledQuestionsOrder = shuffleArray(originalIndices); // This now stores shuffled *original indices*
      localStorage.setItem("shuffledQuestionsOrder", JSON.stringify(shuffledQuestionsOrder));
      
      // Rebuild the 'questions' array based on the shuffled order of original indices
      questions = shuffledQuestionsOrder.map(index => originalQuestions[index]);
      
      // Reset answers, options order, and times as the question order has changed fundamentally
      answers = {}; 
      localStorage.removeItem("quizAnswers");
      shuffledOptionsOrder = {}; 
      localStorage.removeItem("shuffledOptionsOrder");
      questionTimes = {};
      localStorage.removeItem("questionTimes");

      buildSidebarLinks(); // Rebuild sidebar (it should still map to original question numbers)
      loadQuestion(0); // Load the first question from the new shuffled 'questions' array
      updateScoreSummary();
      updateProgress();
    }

    function resetQuestionOrder() {
      questions = [...originalQuestions]; // Reset to original order
      shuffledQuestionsOrder = null;
      localStorage.removeItem("shuffledQuestionsOrder");
      
      // Reset answers, options order, and times
      answers = {};
      localStorage.removeItem("quizAnswers");
      shuffledOptionsOrder = {};
      localStorage.removeItem("shuffledOptionsOrder");
      questionTimes = {};
      localStorage.removeItem("questionTimes");
      
      buildSidebarLinks();
      loadQuestion(0);
      updateScoreSummary();
      updateProgress();
    }

    function shuffleOptions() {
      shuffledOptionsOrder = {}; // This will store option orders keyed by the *current shuffled index* of questions
      questions.forEach((q, currentShuffledIdx) => {
        const originalOptionIndices = Array.from({length: q.options.length}, (_, j) => j);
        shuffledOptionsOrder[currentShuffledIdx] = shuffleArray(originalOptionIndices);
      });
      localStorage.setItem("shuffledOptionsOrder", JSON.stringify(shuffledOptionsOrder));
      loadQuestion(current); // Reload current question to apply shuffled options
    }

    function updateScoreSummary() {
      let correct = 0;
      let wrong = 0;
      // Iterate through the 'questions' array (which is the source of truth for current display)
      questions.forEach((q, idxInShuffled) => { // idxInShuffled is the key for 'answers' and 'shuffledOptionsOrder'
        const originalQuestionDetails = originalQuestions.find(oq => oq.question === q.question);
        const userAnswerOriginalOptionIndex = answers[idxInShuffled]; // User's answer (original option index)

        if (userAnswerOriginalOptionIndex !== undefined) {
          if (userAnswerOriginalOptionIndex === originalQuestionDetails.answer) correct++;
          else wrong++;
        }
      });
      const scoreSummary = document.getElementById("score-summary");
      if (scoreSummary) {
        scoreSummary.innerText = `सही उत्तर: ${correct} | गलत उत्तर: ${wrong}`;
      }
    }

    window.onload = () => {
      const body = document.body;
      const sidebar = document.getElementById("sidebar");
      if (body.clientWidth > 768) {
        sidebar.classList.remove("hidden");
        body.classList.add("sidebar-visible");
        body.style.paddingLeft = "240px";
      } else {
        sidebar.classList.add("hidden");
        body.classList.remove("sidebar-visible");
        body.style.paddingLeft = "20px";
      }

      // Initialize 'questions' array based on whether there's a saved shuffled order
      if (shuffledQuestionsOrder) {
          questions = shuffledQuestionsOrder.map(index => originalQuestions[index]);
      } else {
          questions = [...originalQuestions];
      }
      
      // Load saved current question index (this index refers to the position in the 'questions' array)
      const savedQuestionIndex = localStorage.getItem("currentQuestion");
      if (savedQuestionIndex !== null && parseInt(savedQuestionIndex) < questions.length) {
        current = parseInt(savedQuestionIndex);
      } else {
        current = 0; // Default to the first question
      }
      
      applyFontSize();
      buildSidebarLinks(); // Builds links based on originalQuestions but maps to shuffled for loading
      loadQuestion(current); // Load the question at 'current' index from 'questions' array
      setInitialIcons();
      updateScoreSummary(); // Update score based on loaded answers
      updateProgress();     // Update progress based on loaded answers
    };

    window.onresize = () => {
      const body = document.body;
      const sidebar = document.getElementById("sidebar");
      if (body.clientWidth > 768) {
        body.style.paddingLeft = sidebar.classList.contains("hidden") ? "20px" : "240px";
        if (!sidebar.classList.contains("hidden")) { // if sidebar is visible
             body.classList.add("sidebar-visible");
        } else {
            body.classList.remove("sidebar-visible");
        }
      } else { // Mobile view
        body.style.paddingLeft = "20px"; // Default padding when sidebar is hidden or could be overlayed
         if (!sidebar.classList.contains("hidden")) { // if sidebar is visible (likely overlayed)
            // Mobile might not need padding adjustment if sidebar overlays
            // However, if the quiz content needs to shift, adjust here.
            // For current setup, toggle button handles sidebar visibility.
            // Ensure body.sidebar-visible is correctly managed by toggleSidebar for mobile if needed for content shift.
            // The current toggleSidebar handles padding for mobile when sidebar becomes visible.
        }
      }
    };
  </script>
</body>
</html>
